<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;CTE&lt;/strong&gt;: Common Table Expressions, 也就是我们常见的 With clause."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>SQL CTE 优化 | Jiatao Tao's blog</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/CTE/" rel="tag">CTE</a><a class="post-tag-none-link" href="/tags/OLAP/" rel="tag">OLAP</a><a class="post-tag-none-link" href="/tags/Optimizer/" rel="tag">Optimizer</a><a class="post-tag-none-link" href="/tags/SQL/" rel="tag">SQL</a></div><div class="post-time">2021-05-01</div></div></div><div class="container post-header"><h1>SQL CTE 优化</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98"><span class="toc-number">1.1.</span> <span class="toc-text">挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">解决死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%9A%E4%B8%BE-%E9%80%89%E5%8F%96%E5%8F%AF%E8%83%BD%E7%9A%84%E8%AE%A1%E5%88%92"><span class="toc-number">1.1.2.</span> <span class="toc-text">如何枚举&#x2F;选取可能的计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">如何根据上下文优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">优化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">名词定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-CTE-%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">嵌套 CTE 例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PLAN-ENUMERATION"><span class="toc-number">2.2.</span> <span class="toc-text">PLAN ENUMERATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memo-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">Memo 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Init-Memo"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">Init Memo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Apply-transformation-implement-rule"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">Apply transformation&#x2F;implement rule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Find-best-plan"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">Find best plan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CTE-Transformation"><span class="toc-number">2.2.2.</span> <span class="toc-text">CTE Transformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate-Pushdown"><span class="toc-number">2.2.3.</span> <span class="toc-text">Predicate Pushdown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Always-Inlining-Single-use-CTEs"><span class="toc-number">2.2.4.</span> <span class="toc-text">Always Inlining Single-use CTEs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elimination-of-unused-CTEs"><span class="toc-number">2.2.5.</span> <span class="toc-text">Elimination of unused CTEs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CONTEXTUALIZED-OPTIMIZATION"><span class="toc-number">2.3.</span> <span class="toc-text">CONTEXTUALIZED OPTIMIZATION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Enforcing-Physical-Properties"><span class="toc-number">2.3.1.</span> <span class="toc-text">Enforcing Physical Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer-Context"><span class="toc-number">2.3.2.</span> <span class="toc-text">Producer Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer-Context"><span class="toc-number">2.3.3.</span> <span class="toc-text">Consumer Context</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CTE-BASED-OPTIMIZATIONS"><span class="toc-number">2.4.</span> <span class="toc-text">CTE-BASED OPTIMIZATIONS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CTE-Generating-Transformations"><span class="toc-number">2.4.1.</span> <span class="toc-text">CTE-Generating Transformations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Common-Subexpression-Elimination"><span class="toc-number">2.4.2.</span> <span class="toc-text">Common Subexpression Elimination</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>CTE</strong>: Common Table Expressions, 也就是我们常见的 With clause.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i<span class="operator">-</span>brand, i_current_price, <span class="built_in">MAX</span> (i_units) m</span><br><span class="line">           <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">           <span class="keyword">GROUP</span> <span class="keyword">BY</span> ibrand, i_current_price)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v <span class="keyword">WHERE</span> m <span class="operator">&lt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><strong>CTE 优点:</strong></p>
<ol>
<li>简化查询, 使其更可读</li>
<li>性能提升(本文主要介绍非递归 CTE 带来的性能提升)</li>
</ol>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><ul>
<li>复杂的查询可能会有嵌套的 CTE, 优化器需要保证没有同时多个 process 在等对方结束</li>
</ul>
<h3 id="如何枚举-选取可能的计划"><a href="#如何枚举-选取可能的计划" class="headerlink" title="如何枚举/选取可能的计划"></a>如何枚举/选取可能的计划</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL2</span></span><br><span class="line"><span class="comment">-- index on i_color</span></span><br><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_brand, i_color <span class="keyword">FROM</span> item </span><br><span class="line">           <span class="keyword">WHERE</span> i_CURRENT_price <span class="operator">&lt;</span> <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">SELECT</span> v1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> y vl, v v2, v v3</span><br><span class="line"><span class="keyword">WHERE</span> vl.i_brand <span class="operator">=</span> v2.i_brand</span><br><span class="line">  <span class="keyword">AND</span> v2.i_brand <span class="operator">=</span> v3.i_brand</span><br><span class="line">  <span class="keyword">AND</span> v3.i_color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于 <strong>SQL2</strong>, 有几种 CTE 展开的形式</p>
<p>a. 不展开: CTE 只执行一次, 但是没有用到 i_color 上的 index</p>
<p>b. 全部展开: 可以使用 i_color 上的 index, 但是展开的部分重复计算了三次</p>
<p>c. 部分展开</p>
<p>![image-20210426183446419](SQL CTE 优化/image-20210426183446419-20210507210541900.png)</p>
<h3 id="如何根据上下文优化"><a href="#如何根据上下文优化" class="headerlink" title="如何根据上下文优化"></a>如何根据上下文优化</h3><ol>
<li>如果查询对所有的 CTE 都有 filter, 可以直接把 filter 下推到 CTE 的定义上</li>
<li>分布式计划中的物理属性的 enforce, 减少对同一份数据的re-partition/re-ordering</li>
</ol>
<h1 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a>优化流程</h1><h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL3</span></span><br><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_brand <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_color <span class="operator">=</span> ’red’) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v <span class="keyword">as</span> v1, v <span class="keyword">as</span> v2 <span class="keyword">WHERE</span> v1.i_brand <span class="operator">=</span> v2.i_brand;</span><br></pre></td></tr></table></figure>

<p>![image-20210426205405612](SQL CTE 优化/image-20210426205405612-20210507210542053.png)</p>
<ol>
<li><strong>CTEProducer</strong>: CTE 定义的树的根节点, 有唯一的 ID.</li>
<li><strong>CTEConsumer</strong>: query 里用到 CTE 的地方, ID 与其对应的 CTEProducer 一致.</li>
<li><strong>CTEAnchor</strong>: 定义了 CTE 的作用域, 一个 CTE 仅可以在被其相对应的 CTEAnchor 下被引用.</li>
<li><strong>Sequence</strong>: 二元操作符, 按顺序执行其 children (从左到右), 然后返回其 right child.</li>
</ol>
<p>图三展示了 SQL3 的两种可能的 plan.</p>
<ul>
<li>a. 所有 CTEs 都被内联了, CTEAnchor 被去除, 所有的 CTEConsumer 都被替换成 CTE 展开的定义</li>
<li>b. 无内联, CTEAnchor 被替换成 Sequence, CTEProducer 作为其 left child, CTEAnchor 的 child 作为其 right child<ul>
<li><strong>Sequence</strong> 保证了特定的执行顺序, 可以保证 CTEProducer 在 CTEConsumer 之前执行. 这个机制可以保证生成的计划没有死锁</li>
</ul>
</li>
</ul>
<p>![image-20210427111008104](SQL CTE 优化/image-20210427111008104-20210507210542029.png)</p>
<h3 id="嵌套-CTE-例子"><a href="#嵌套-CTE-例子" class="headerlink" title="嵌套 CTE 例子"></a>嵌套 CTE 例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL4</span></span><br><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_current_price <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_color <span class="operator">=</span> ’red’),</span><br><span class="line">     w <span class="keyword">AS</span> (<span class="keyword">SELECT</span> v1.p <span class="keyword">FROM</span> v <span class="keyword">AS</span> v1, v <span class="keyword">AS</span> v2 <span class="keyword">WHERE</span> v1.p <span class="operator">&lt;</span> v2.p)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v <span class="keyword">AS</span> v3, w <span class="keyword">AS</span> w1, w <span class="keyword">AS</span> w2</span><br><span class="line"><span class="keyword">WHERE</span> v3.p <span class="operator">&lt;</span> w1.p <span class="operator">+</span> w2.p;</span><br></pre></td></tr></table></figure>

<p>![image-20210427142643234](SQL CTE 优化/image-20210427142643234-20210507210542091.png)</p>
<p>注意, 图 b 有两个 CTEAnchor, 其顺序和在 with 定义里的一致</p>
<h2 id="PLAN-ENUMERATION"><a href="#PLAN-ENUMERATION" class="headerlink" title="PLAN ENUMERATION"></a>PLAN ENUMERATION</h2><h3 id="Memo-介绍"><a href="#Memo-介绍" class="headerlink" title="Memo 介绍"></a>Memo 介绍</h3><ul>
<li>MEMO 的定义：是一种数据结构，用于管理一个组，每个组代表一个查询计划的不同子目标。</li>
<li>MEMO 结构的目标：是通过尽可能的公用相同的子树使得内存的使用最小。</li>
<li>MEMO 的主要思想：通过使用共享的副本来避免子树的重复使用。</li>
</ul>
<p>Memo 中两个最基本的概念就是 Expression Group（简称 Group） 以及 Group Expression（对应关系代数算子）</p>
<ul>
<li>每个 Group 中保存的是逻辑等价的 Group Expression</li>
<li>Group Expression 的子节点是由 Group 组成</li>
</ul>
<h4 id="Init-Memo"><a href="#Init-Memo" class="headerlink" title="Init Memo"></a>Init Memo</h4><p>![image-20200208221706543](SQL CTE 优化/image-20200208221706543-20210507210542129.png)</p>
<p>一旦最初的计划复制到了MEMO结构中以后，就可以对逻辑操作符做一些转换以生成物理操作符。<br>一个转换规则可以生成：</p>
<ol>
<li>同一组中的一个逻辑操作符: 如 join( A, B) -&gt; join( B, A)</li>
<li>同一组中的一个物理操作符: 如 join -&gt; Hash Join</li>
</ol>
<h4 id="Apply-transformation-implement-rule"><a href="#Apply-transformation-implement-rule" class="headerlink" title="Apply transformation/implement rule"></a>Apply transformation/implement rule</h4><p>![image-20200208221734549](SQL CTE 优化/image-20200208221734549-20210507210542169.png)</p>
<p>一组逻辑操作符组成一个子计划。根仍保留在原来的组中，而其他操作符分配到其他的组中，必要的时候可以建立新组，如 join( A, join(B,C)) -&gt; join( join(A,B), C), 这两个最外面的 Join 是等价的, 所以是同一个根节点, 但是前后两次里面的 join 不一样, 所以在不同的组</p>
<h4 id="Find-best-plan"><a href="#Find-best-plan" class="headerlink" title="Find best plan"></a>Find best plan</h4><p>![image-20200208221741219](SQL CTE 优化/image-20200208221741219-20210507210542188.png)</p>
<h3 id="CTE-Transformation"><a href="#CTE-Transformation" class="headerlink" title="CTE Transformation"></a>CTE Transformation</h3><p>使用 Memo 代表不同的候选者使得这个过程是 CBO 的, 我们可以在一条查询中内联某些 CTE, 其他的不内联.</p>
<p>![image-20210427144511944](SQL CTE 优化/image-20210427144511944-20210507210542294.png)</p>
<ol>
<li>首先生成一个初始的 memo (F.6)</li>
<li>第一条 rule 应用在 CTEAnchor 上, 生成一个 Sequence 节点(group 0), 同时把 CTEProducer 作为其 left child 展开, 生成了 group 4/5/6, 其 right child 是CTEAnchor 的 child</li>
<li>第二条 rule 还是应用在 CTEAnchor, 生成一个 NoOp 算子, child 是 CTEAnchor 的 child</li>
<li>第三条 rule 应用在 CTEConsumer 上, 生成一个展开后的 CTE 定义, 添加到 CTEConsumer 的同一个 group 中</li>
</ol>
<p>F.8 展示了一些可能的 plan, 这些 plan 都有一些问题:</p>
<ul>
<li>8(a)/8(b) 是非法的, 他们只有 CTEConsumer, 却没有 CTEProducer, 所以 CTEConsumer 永远也读不到他们想要的数据. 我们会避免产生这样的计划</li>
<li>8(c)/8(d) 的计划明显不是最优的, c 展开了所有的 CTE, 但是保留了 CTEProducer, 同理 d 也是.</li>
</ul>
<p>![image-20210427145718543](SQL CTE 优化/image-20210427145718543-20210507210542229.png)</p>
<h3 id="Predicate-Pushdown"><a href="#Predicate-Pushdown" class="headerlink" title="Predicate Pushdown"></a>Predicate Pushdown</h3><p>在 Orca, 我们引入了一种方法, 可以不展开 CTE 也可以做谓词下推.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL5</span></span><br><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_brand, i_color <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_CURRENT price <span class="operator">&lt;</span> <span class="number">50</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v v1, v v2</span><br><span class="line"><span class="keyword">WHERE</span> v1.i_brand <span class="operator">=</span> v2.i_brand</span><br><span class="line">  <span class="keyword">AND</span> v1.i_color <span class="operator">=</span> ’red’</span><br><span class="line">  <span class="keyword">AND</span> v2.i_color <span class="operator">=</span> ’blue’;</span><br></pre></td></tr></table></figure>

<p>![image-20210427153800222](SQL CTE 优化/image-20210427153800222-20210507210542245.png)</p>
<h3 id="Always-Inlining-Single-use-CTEs"><a href="#Always-Inlining-Single-use-CTEs" class="headerlink" title="Always Inlining Single-use CTEs"></a>Always Inlining Single-use CTEs</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL6</span></span><br><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_color <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_current_price <span class="operator">&lt;</span> <span class="number">50</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v <span class="keyword">WHERE</span> v.i_color <span class="operator">=</span> ’red’;</span><br></pre></td></tr></table></figure>

<p>由于这类 CTE 只被使用了一次, 所以可以无脑 inline</p>
<h3 id="Elimination-of-unused-CTEs"><a href="#Elimination-of-unused-CTEs" class="headerlink" title="Elimination of unused CTEs"></a>Elimination of unused CTEs</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> v <span class="keyword">AS</span> (<span class="keyword">SELECT</span> i_color <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> i_current_price <span class="operator">&lt;</span> <span class="number">50</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> item <span class="keyword">WHERE</span> item.i_color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当 CTE 没有被使用到的时候, 直接消除掉. 当 CTE 有嵌套定义时, 可以先消除最外层定义的 CTE, 外层的 CTE 消除之后, 内层的 CTE 也无引用, 也可以消除.</p>
<h2 id="CONTEXTUALIZED-OPTIMIZATION"><a href="#CONTEXTUALIZED-OPTIMIZATION" class="headerlink" title="CONTEXTUALIZED OPTIMIZATION"></a>CONTEXTUALIZED OPTIMIZATION</h2><h3 id="Enforcing-Physical-Properties"><a href="#Enforcing-Physical-Properties" class="headerlink" title="Enforcing Physical Properties"></a>Enforcing Physical Properties</h3><p>![image-20210427161134653](SQL CTE 优化/image-20210427161134653-20210507210542580.png)</p>
<h3 id="Producer-Context"><a href="#Producer-Context" class="headerlink" title="Producer Context"></a>Producer Context</h3><p>CTEProducer 侧的计划生成比较独立, 可以不考虑 Consumer 侧. 如图 11(a), CTEProducer 侧并不需要任何分布, 所以没有添加任何 distribution. 但是 Consumer 测有个 hash join, 所以需要其底下的算子提供 HashDistribution, 但这不是最优的计划.</p>
<h3 id="Consumer-Context"><a href="#Consumer-Context" class="headerlink" title="Consumer Context"></a>Consumer Context</h3><p>先从 Consumer 侧来考虑数据分布, 可以产生的更优的计划. 如图 11(b). 这种方式把 distribution 下推到了 CTE 中, 这样在 consumer 测就不用做 distribution.</p>
<h2 id="CTE-BASED-OPTIMIZATIONS"><a href="#CTE-BASED-OPTIMIZATIONS" class="headerlink" title="CTE-BASED OPTIMIZATIONS"></a>CTE-BASED OPTIMIZATIONS</h2><h3 id="CTE-Generating-Transformations"><a href="#CTE-Generating-Transformations" class="headerlink" title="CTE-Generating Transformations"></a>CTE-Generating Transformations</h3><p>在以下场景 window function, full outer joins, distinct aggregates , Orca 会自动生成 CTE.</p>
<p>例如下面的 SQL9, distinct 了两个不同的列, 可以把 P-F-T 的部分提成一个 CTE, 减少读取的 input.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL9</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cs_item_sk), <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> cs_qty)</span><br><span class="line"><span class="keyword">FROM</span> CATALOG sales <span class="keyword">WHERE</span> cs_net profit <span class="operator">&gt;</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>![image-20210427200049532](SQL CTE 优化/image-20210427200049532-20210507210542308.png)</p>
<h3 id="Common-Subexpression-Elimination"><a href="#Common-Subexpression-Elimination" class="headerlink" title="Common Subexpression Elimination"></a>Common Subexpression Elimination</h3><p>Orca可以提取公共子表达式为 CTE.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> i_brand, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> b <span class="keyword">FROM</span> item <span class="keyword">GROUP</span> <span class="keyword">BY</span> i_brand <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>) t1,</span><br><span class="line">  (<span class="keyword">SELECT</span> i_brand, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> b <span class="keyword">FROM</span> item <span class="keyword">GROUP</span> <span class="keyword">BY</span> i_brand <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">20</span>) t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.i_brand <span class="operator">&lt;&gt;</span> t2.i_brand;</span><br></pre></td></tr></table></figure>

<p>![image-20210427202305622](SQL CTE 优化/image-20210427202305622-20210507210542337.png)</p>
<p>具体算法如下:</p>
<ul>
<li>输入: 原始表达式</li>
<li>输出: common subexpression 已经被替换过的表达式</li>
<li>DetectMatches() 用于找出公共的表达式, 论文中又引用了其他两篇论文<ul>
<li>Exploiting Common Subexpressions for Cloud Query Processing.</li>
<li>Efﬁcient Exploitation of Similar Subexpressions for Query Processing.</li>
</ul>
</li>
<li>InsertCTEConsumers() 把表达式中的公共子表达式替换为对应的 CTEConsumer</li>
<li>最后, 在每组公共子表达式的 LCA(最近公共祖先) 处插入一个CTEAnchor</li>
</ul>
<p>![image-20210427202537374](SQL CTE 优化/image-20210427202537374-20210507210542586.png)</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>