<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="oi9cACXaYdEyQVeGEUG_WUOEeFyJe9ey2Sj7Dcribng">
  <meta name="baidu-site-verification" content="code-W1bppEiaZ5">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://aaaaaaron.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: false,
    comments: {"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="原文转发自知乎叶绿素: https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;545776764 目录 核心概念：IProcessor和Port（ISink、ISource、IXXXTransform、InputPort、OutputPort…）未完成 pipeline的组装：QueryPlan、IQueryPlanStep、QueryPipelineBuilders、Pipe、QueryPi">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse之Pipeline执行引擎">
<meta property="og:url" content="https://aaaaaaron.github.io/2023/02/19/ClickHouse%E4%B9%8BPipeline%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/index.html">
<meta property="og:site_name" content="Tao&#39;s blog">
<meta property="og:description" content="原文转发自知乎叶绿素: https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;545776764 目录 核心概念：IProcessor和Port（ISink、ISource、IXXXTransform、InputPort、OutputPort…）未完成 pipeline的组装：QueryPlan、IQueryPlanStep、QueryPipelineBuilders、Pipe、QueryPi">
<meta property="og:locale">
<meta property="article:published_time" content="2023-02-19T10:37:35.000Z">
<meta property="article:modified_time" content="2023-02-10T09:10:03.564Z">
<meta property="article:author" content="Tao">
<meta property="article:tag" content="clickhouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aaaaaaron.github.io/2023/02/19/ClickHouse%E4%B9%8BPipeline%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>ClickHouse之Pipeline执行引擎 | Tao's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tao's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">λ</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-desktop"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://aaaaaaron.github.io/2023/02/19/ClickHouse%E4%B9%8BPipeline%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Tao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          ClickHouse之Pipeline执行引擎
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 18:37:35" itemprop="dateCreated datePublished" datetime="2023-02-19T18:37:35+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-10 17:10:03" itemprop="dateModified" datetime="2023-02-10T17:10:03+08:00">2023-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>原文转发自知乎叶绿素: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/545776764">https://zhuanlan.zhihu.com/p/545776764</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>核心概念：IProcessor和Port（ISink、ISource、IXXXTransform、InputPort、OutputPort…）<strong>未完成</strong></li>
<li>pipeline的组装：QueryPlan、IQueryPlanStep、QueryPipelineBuilders、Pipe、QueryPipeline <strong>未完成</strong></li>
<li>pipeline的执行：PipelineExecutor、push模型和pull模型 <strong>本篇</strong></li>
<li>pipeline的特点：支持运行时扩展（不单独分析，参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/591575835">这篇文章</a>）、支持与网络io结合 <strong>本篇</strong></li>
</ul>
<h2 id="关于PipelineExecutor"><a href="#关于PipelineExecutor" class="headerlink" title="关于PipelineExecutor"></a>关于PipelineExecutor</h2><p>位置:src/Processors/Executors/PipelineExecutor.h</p>
<p>代表query pipeline的调度器，主要数据成员：</p>
<p>ExecutingGraph(graph)；</p>
<ul>
<li>pipeline在执行前，会被执行器转换成一个ExecutingGraph，由一组Node和对应的Edge集合组成，Node代表单个的Processor，Edge代表连接着OutputPort和InputPort的对象。每个Node持有两条边，分别为direct_edges和back_edges，direct_edges代表本Node的outputport连接其他inputport，back_edges代表某个outputport连接本Node的inputport。</li>
</ul>
<p>ExecutorTasks(tasks)；</p>
<ul>
<li>管理可以被调度执行的任务，主要数据成员如下：</li>
</ul>
<ol>
<li>executor_contexts;（work线程上下文）</li>
<li>task_queue;（可以被调度执行的Node集合）</li>
<li>threads_queue;（由于缺少任务被挂起的线程id集合）</li>
</ol>
<p>调用链：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PipelineExecutor::<span class="built_in">execute</span>(<span class="keyword">size_t</span> num_threads)</span><br><span class="line">-&gt; <span class="built_in">executeImpl</span>(num_threads);</span><br><span class="line">  -&gt; <span class="built_in">initializeExecution</span>(num_threads);</span><br><span class="line">    -&gt; graph-&gt;<span class="built_in">initializeExecution</span>(queue);</span><br><span class="line">    <span class="comment">// 将所有direct_edges为空的Node提取出来，依次调用updateNode。</span></span><br><span class="line">      -&gt; <span class="built_in">updateNode</span>(proc, queue, async_queue);               （<span class="number">2</span>）</span><br><span class="line">     <span class="comment">// 以proc为起点，调用prepare函数，如果遇到Ready的node则push到queue中，  如果遇到Async的node则push到async_queue中。然后更新与当前node关联的edge，  通过edge找到下一个node并执行该node的prepare方法，最终将所有状态为Ready      和Async的node放到对应的队列中。</span></span><br><span class="line">    -&gt; tasks.<span class="built_in">init</span>();</span><br><span class="line">    -&gt; tasks.<span class="built_in">fill</span>(queue);</span><br><span class="line">    <span class="comment">//tasks持有线程队列和任务队列（任务队列是个二维数组，及为每个线程维护一个任务队列，详情见TaskQueue类），tasks.fill(queue)实际上就是将就绪的node依次分配到任务队列中。</span></span><br><span class="line">   -&gt; threads.<span class="built_in">emplace_back</span>(executeSingleThread);</span><br><span class="line">   <span class="comment">//在栈上创建一个线程池，依次调用executeSingleThread函数：</span></span><br><span class="line">     -&gt; <span class="built_in">executeStepImpl</span>(thread_num);</span><br><span class="line">       -&gt; <span class="keyword">auto</span>&amp; context = tasks.<span class="built_in">getThreadContext</span>(thread_num);</span><br><span class="line">       -&gt; tasks.<span class="built_in">tryGetTask</span>(context);</span><br><span class="line">       <span class="comment">// 首先尝试从本上下文中获取异步task，如果没有的话尝试从task_queue中获取一个task。</span></span><br><span class="line">       <span class="comment">// 如果task_queue为空并且async_task也为空的话，则将context.thread_number插入thread_queue（这个对象中记录着当前等待着task的线程id）中，并wait在wakeup_flag || finished上；如果context取到了task，则调用tryWakeupAnyOtherThreadWithTasks函数。</span></span><br><span class="line">         -&gt; <span class="built_in">tryWakeupAnyOtherThreadWithTasks</span>(self, lock);</span><br><span class="line">         <span class="comment">// 这个函数的目的在于获取一个等待任务的线程进行唤醒：executor_contexts[thread_to_wake]-&gt;wakeUp();</span></span><br><span class="line">       -&gt; context.<span class="built_in">executeTask</span>();</span><br><span class="line">         -&gt; <span class="built_in">executeJob</span>(node, read_progress_callback);</span><br><span class="line">           -&gt; node-&gt;processor-&gt;<span class="built_in">work</span>();</span><br><span class="line">         -&gt; graph-&gt;<span class="built_in">updateNode</span>(context.<span class="built_in">getProcessorID</span>(), queue, async_queue);  （<span class="number">1</span>）</span><br><span class="line">         -&gt; tasks.<span class="built_in">pushTasks</span>(queue, async_queue, context);</span><br><span class="line">         <span class="comment">// 将queue中的node插入task_queue，并唤醒其他线程来处理task</span></span><br><span class="line">           -&gt; <span class="built_in">tryWakeupAnyOtherThreadWithTasks</span>(context, lock);</span><br></pre></td></tr></table></figure>

<p>总结PipelineExecutor的调度流程：</p>
<p>从ExecutingGraph中获取direct_edges为空的Node并调用其prepare函数。direct_edges为空的Node一般来说就是ISink类型的节点，即最终的消费者。可以在ISink函数中看到其prepare函数的实现，首次调用时总是会返回Ready，因此调度器会调用其work函数，对ISink对象首次调用work函数会触发OnStart回调。</p>
<p>work函数调用之后，调度器会对该节点调用updateNode函数（见（1）），updateNode具体逻辑在（2）这里，即再次调用其prepare函数。这时ISink会调用input.setNeed函数，这个函数会唤醒对应的Edge（updated_edges.push(edge)），在updateNode逻辑中会处理这些Edge，获取对应的Node继续prepare操作。</p>
<p>因此，可以根据Edge关系从ISink节点出发，一直找到ISource节点并调用其prepare函数，对于ISource节点来说只要output_port可以push就返回Ready，由调度器调用work函数，work函数中执行tryGenerate函数（真正生成数据的函数）。因此当调度器再次执行其prepare函数时，执行output.pushData函数，这个函数和input.setNeed同样会唤醒对应的Edge，因此调度器会找到其下游节点调用prepare函数，这时数据已经从ISource节点交付，因此下游节点会返回Ready，调度器调用其work函数…从上游节点到最终的ISink节点重复这个操作。</p>
<p>最后我们会回到ISink节点，调用其work函数，work函数中会调用consume函数消费数据。当再次调用ISink节点的prepare函数时，会再次调用input.setNeed函数，这样就形成了一个循环。</p>
<p>可以看到，PipelineExecutor是一个pull模型的调度器，我们每次总ISink节点开始向上游节点请求数据，通过唤醒Edge将请求传递到ISource节点，在ISource节点中生产数据，交付下游节点处理，最终回到ISink节点消费数据，如果还有数据需要消费的话，ISink节点会再次向上游节点请求；当数据消费完成后，ISource节点会通过关闭output_port通知下游节点，最终完成所有数据的处理。</p>
<h2 id="封装PipelineExecutor"><a href="#封装PipelineExecutor" class="headerlink" title="封装PipelineExecutor"></a>封装PipelineExecutor</h2><p>在ClickHouse中并不是直接通过PipelineExecutor进行调度，而是将其封装在PullingAsyncPipelineExecutor、PullingPipelineExecutor、PushingAsyncPipelineExecutor、PushingPipelineExecutor等中进一步封装使用。其中PullingAsyncPipelineExecutor和PullingPipelineExecutor是pull模型的调度器，其区别在于是在当前线程调度还是申请一个线程进行调度。这两个调度器对PipelineExecutor的封装比较浅，原因如上，PipelineExecutor也是pull模型。而PushingAsyncPipelineExecutor和PushingPipelineExecutor是push模型的调度器，接下来以PushingAsyncPipelineExecutor为例进行分析，说明这是如何实现的。</p>
<p>在PushingAsyncPipelineExecutor中定义了一个ISource子类型PushingAsyncSource：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class PushingAsyncSource : public ISource</span><br></pre></td></tr></table></figure>

<p>在构造函数中创建了一个PushingAsyncSource的对象pushing_source，并将其连接到pipeline的input上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PushingAsyncPipelineExecutor::PushingAsyncPipelineExecutor(QueryPipeline &amp; pipeline_) : pipeline(pipeline_)</span><br><span class="line">&#123;</span><br><span class="line"> if (!pipeline.pushing())</span><br><span class="line">   throw Exception(ErrorCodes::LOGICAL_ERROR, &quot;Pipeline for PushingPipelineExecutor must be pushing&quot;);</span><br><span class="line"></span><br><span class="line"> pushing_source = std::make_shared&lt;PushingAsyncSource&gt;(pipeline.input-&gt;getHeader());</span><br><span class="line"> connect(pushing_source-&gt;getPort(), *pipeline.input);</span><br><span class="line"> pipeline.processors.emplace_back(pushing_source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PushingAsyncPipelineExecutor的start函数如下，可以看到没有什么特别的地方，构造一个PipelineExecutor，并在threadFunction中调用execute()函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void PushingAsyncPipelineExecutor::start()</span><br><span class="line">&#123;</span><br><span class="line"> if (started)</span><br><span class="line">   return;</span><br><span class="line"></span><br><span class="line"> started = true;</span><br><span class="line"></span><br><span class="line"> data = std::make_unique&lt;Data&gt;();</span><br><span class="line"> data-&gt;executor = std::make_shared&lt;PipelineExecutor&gt;(pipeline.processors, pipeline.process_list_element);</span><br><span class="line"> data-&gt;executor-&gt;setReadProgressCallback(pipeline.getReadProgressCallback());</span><br><span class="line"> data-&gt;source = pushing_source.get();</span><br><span class="line"></span><br><span class="line"> auto func = [&amp;, thread_group = CurrentThread::getGroup()]()</span><br><span class="line"> &#123;</span><br><span class="line">   threadFunction(*data, thread_group, pipeline.getNumThreads());</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> data-&gt;thread = ThreadFromGlobalPool(std::move(func));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次在push数据时，将数据传入pushing_source：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void PushingAsyncPipelineExecutor::push(Chunk chunk)</span><br><span class="line">&#123;</span><br><span class="line"> if (!started)</span><br><span class="line">   start();</span><br><span class="line"></span><br><span class="line"> bool is_pushed = pushing_source-&gt;setData(std::move(chunk));</span><br><span class="line"> data-&gt;rethrowExceptionIfHas();</span><br><span class="line"></span><br><span class="line"> if (!is_pushed)</span><br><span class="line">   throw Exception(ErrorCodes::LOGICAL_ERROR,</span><br><span class="line">     &quot;Pipeline for PushingPipelineExecutor was finished before all data was inserted&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看PushingAsyncSource的定义，注意在generate()中等待在条件变量condvar上，只有当setData()或者finish()时才会唤醒generate()继续执行。所以，当PipelineExecutor调度时，首先从ISink一路请求数据到ISource，ISource的work函数会等待用户push数据，拿到数据后将数据传递给下游节点处理，最终到达ISink。如果还没有结束，ISink会重复这一逻辑，即再次一路请求数据到ISource并等待用户push数据。这样就利用pull模型的PipelineExecutor实现了push模型的调度器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class PushingAsyncSource : public ISource</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> explicit PushingAsyncSource(const Block &amp; header)</span><br><span class="line">        : ISource(header)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"> String getName() const override &#123; return &quot;PushingAsyncSource&quot;; &#125;</span><br><span class="line"></span><br><span class="line"> bool setData(Chunk chunk)</span><br><span class="line"> &#123;</span><br><span class="line">   std::unique_lock lock(mutex);</span><br><span class="line">   condvar.wait(lock, [this] &#123; return !has_data || is_finished; &#125;);</span><br><span class="line"></span><br><span class="line">   if (is_finished)</span><br><span class="line">     return false;</span><br><span class="line"></span><br><span class="line">   data.swap(chunk);</span><br><span class="line">   has_data = true;</span><br><span class="line">   condvar.notify_one();</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void finish()</span><br><span class="line"> &#123;</span><br><span class="line">   std::unique_lock lock(mutex);</span><br><span class="line">   is_finished = true;</span><br><span class="line">   condvar.notify_all();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"> Chunk generate() override</span><br><span class="line"> &#123;</span><br><span class="line">   std::unique_lock lock(mutex);</span><br><span class="line">   condvar.wait(lock, [this] &#123; return has_data || is_finished; &#125;);</span><br><span class="line">   Chunk res;</span><br><span class="line"></span><br><span class="line">   res.swap(data);</span><br><span class="line">   has_data = false;</span><br><span class="line">   condvar.notify_one();</span><br><span class="line">   return res;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"> Chunk data;</span><br><span class="line"> bool has_data = false;</span><br><span class="line"> bool is_finished = false;</span><br><span class="line"> std::mutex mutex;</span><br><span class="line"> std::condition_variable condvar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>push模型调度器在TCPHandler::processInsertQuery()函数中调用，用于处理Insert语句，而pull模型调度器在TCPHandler::processOrdinaryQueryWithProcessors()函数中调用，处理非Insert语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// Processing Query</span><br><span class="line">state.io = executeQuery(state.query, query_context, false, state.stage);</span><br><span class="line"></span><br><span class="line">after_check_cancelled.restart();</span><br><span class="line">after_send_progress.restart();</span><br><span class="line"></span><br><span class="line">if (state.io.pipeline.pushing())</span><br><span class="line">/// FIXME: check explicitly that insert query suggests to receive data via native protocol,</span><br><span class="line">&#123;</span><br><span class="line">    state.need_receive_data_for_insert = true;</span><br><span class="line">    processInsertQuery();</span><br><span class="line"> &#125;</span><br><span class="line"> else if (state.io.pipeline.pulling())</span><br><span class="line"> &#123;</span><br><span class="line">    processOrdinaryQueryWithProcessors();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Status-Async，执行引擎与网络io的无缝衔接"><a href="#Status-Async，执行引擎与网络io的无缝衔接" class="headerlink" title="Status::Async，执行引擎与网络io的无缝衔接"></a>Status::Async，执行引擎与网络io的无缝衔接</h2><p>观察prepare函数返回的枚举类型，其中前四种状态与数据传递相关，后两种比较特别：ExpandPipeline用来支持运行时扩展pipeline，Async用来支持网络io。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/// Processor needs some data at its inputs to proceed.</span></span><br><span class="line">    <span class="comment">/// You need to run another processor to generate required input and then call &#x27;prepare&#x27; again.</span></span><br><span class="line">    NeedData,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Processor cannot proceed because output port is full or not isNeeded().</span></span><br><span class="line">    <span class="comment">/// You need to transfer data from output port to the input port of another processor and then call &#x27;prepare&#x27; again.</span></span><br><span class="line">    PortFull,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// All work is done (all data is processed or all output are closed), nothing more to do.</span></span><br><span class="line">    Finished,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// No one needs data on output ports.</span></span><br><span class="line">    <span class="comment">/// Unneeded,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// You may call &#x27;work&#x27; method and processor will do some work synchronously.</span></span><br><span class="line">    Ready,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// You may call &#x27;schedule&#x27; method and processor will return descriptor.</span></span><br><span class="line">    <span class="comment">/// You need to poll this descriptor and call work() afterwards.</span></span><br><span class="line">    Async,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Processor wants to add other processors to pipeline.</span></span><br><span class="line">    <span class="comment">/// New processors must be obtained by expandPipeline() call.</span></span><br><span class="line">    ExpandPipeline,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搜一下ClickHouse源码，发现状态Async用在<strong>RemoteSource</strong>这个ISource类中，这个类用来支持需要通过网络io获取数据源的情况，比如分布式表（StorageDistributed）、支持S3（StorageS3Cluster）、支持HDFS（StorageHDFSCluster）等情况。</p>
<h3 id="Pipeline执行引擎的视角"><a href="#Pipeline执行引擎的视角" class="headerlink" title="Pipeline执行引擎的视角"></a>Pipeline执行引擎的视角</h3><p>首先从Pipeline执行引擎的视角开始，当节点node的prepare函数返回Status::Async时，该节点被push进async_queue中（updateNode内）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IProcessor::Status::Async:</span><br><span class="line">&#123;</span><br><span class="line">    node.status = ExecutingGraph::ExecStatus::Executing;</span><br><span class="line">    async_queue.<span class="built_in">push</span>(&amp;node);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当updateNode函数返回后，调用tasks.pushTasks函数，将由于本次调度产生的新任务push到全局队列中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Try to execute neighbour processor.</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue queue;</span><br><span class="line">    Queue async_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Prepare processor after execution.</span></span><br><span class="line">    <span class="keyword">if</span> (!graph-&gt;<span class="built_in">updateNode</span>(context.<span class="built_in">getProcessorID</span>(), queue, async_queue))</span><br><span class="line">        <span class="built_in">finish</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Push other tasks to global queue.</span></span><br><span class="line">    tasks.<span class="built_in">pushTasks</span>(queue, async_queue, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void ExecutorTasks::pushTasks(Queue &amp; queue, Queue &amp; async_queue, ExecutionThreadContext &amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    context.setTask(nullptr);</span><br><span class="line"></span><br><span class="line">    /// Take local task from queue if has one.</span><br><span class="line">    if (!queue.empty() &amp;&amp; !context.hasAsyncTasks())</span><br><span class="line">    &#123;</span><br><span class="line">        context.setTask(queue.front());</span><br><span class="line">        queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!queue.empty() || !async_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock lock(mutex);</span><br><span class="line"></span><br><span class="line">#if defined(OS_LINUX)</span><br><span class="line">        while (!async_queue.empty() &amp;&amp; !finished)</span><br><span class="line">        &#123;</span><br><span class="line">            int fd = async_queue.front()-&gt;processor-&gt;schedule();</span><br><span class="line">            async_task_queue.addTask(context.thread_number, async_queue.front(), fd);</span><br><span class="line">            async_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        while (!queue.empty() &amp;&amp; !finished)</span><br><span class="line">        &#123;</span><br><span class="line">            task_queue.push(queue.front(), context.thread_number);</span><br><span class="line">            queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// Wake up at least one thread that will wake up other threads if required</span><br><span class="line">        tryWakeUpAnyOtherThreadWithTasks(context, lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注async_queue部分，通过调用节点的schedule拿到fd，然后调用async_task_queue.addTask函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PollingQueue::addTask</span><span class="params">(<span class="keyword">size_t</span> thread_number, <span class="keyword">void</span> * data, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="keyword">uintptr_t</span> key = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(data);</span><br><span class="line">    <span class="keyword">if</span> (tasks.<span class="built_in">contains</span>(key))</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(ErrorCodes::LOGICAL_ERROR, <span class="string">&quot;Task &#123;&#125; was already added to task queue&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    tasks[key] = TaskData&#123;thread_number, data, fd&#125;;</span><br><span class="line">    epoll.<span class="built_in">add</span>(fd, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实际上就是记录注册节点，并通过epoll监听fd。看来这部分是注册流程，那么epoll是在哪里启动的，当fd就绪时又是如何通知工作线程进行调度的呢？接着看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PipelineExecutor::executeImpl</span><span class="params">(<span class="keyword">size_t</span> num_threads)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initializeExecution</span>(num_threads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> finished_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCOPE_EXIT_SAFE</span>(</span><br><span class="line">        <span class="keyword">if</span> (!finished_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">finish</span>();</span><br><span class="line">            <span class="built_in">joinThreads</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_threads &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">spawnThreads</span>(); <span class="comment">// start at least one thread</span></span><br><span class="line">        tasks.<span class="built_in">processAsyncTasks</span>();</span><br><span class="line">        <span class="built_in">joinThreads</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> slot = slots-&gt;<span class="built_in">tryAcquire</span>();</span><br><span class="line">        <span class="built_in">executeSingleThread</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finished_flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动流程中，spawnThreads()函数启动多个工作线程，之后调用了tasks.processAsyncTasks()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecutorTasks::processAsyncTasks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_LINUX)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// Wait for async tasks.</span></span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">auto</span> task = async_task_queue.<span class="built_in">wait</span>(lock))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> * node = <span class="keyword">static_cast</span>&lt;ExecutingGraph::Node *&gt;(task.data);</span><br><span class="line">            executor_contexts[task.thread_num]-&gt;<span class="built_in">pushAsyncTask</span>(node);</span><br><span class="line">            ++num_waiting_async_tasks;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (threads_queue.<span class="built_in">has</span>(task.thread_num))</span><br><span class="line">            &#123;</span><br><span class="line">                threads_queue.<span class="built_in">pop</span>(task.thread_num);</span><br><span class="line">                executor_contexts[task.thread_num]-&gt;<span class="built_in">wakeUp</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的工作很简单，不断通过epoll_wait获取就绪的 fd对应的节点，并将该节点push到对应线程的上下文中，并且唤醒对应线程处理。<strong>工作线程总是优先处理本上下文中的异步任务，如果没有才会从全局队列中获取任务，</strong>见tasks.tryGetTask函数。</p>
<p>总结一下：</p>
<ul>
<li>调度引擎启动时，启动多个工作线程，并在主线程通过Epoll监听异步任务。</li>
<li>当一个节点等待网络io时，在prepare函数中返回Status::Async，并在schedule函数中返回fd。</li>
<li>调度引擎拿到fd注册到Epoll中，当fd就绪时，主线程负责将对应的异步任务交付给对应的工作线程的上下文，并唤醒该工作线程。</li>
<li>工作线程每次获取任务时总是优先获取异步任务，拿到任务调用work函数。</li>
</ul>
<h3 id="RemoteSource（选读）"><a href="#RemoteSource（选读）" class="headerlink" title="RemoteSource（选读）"></a>RemoteSource（选读）</h3><p>现在看下RemoteSource节点的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;Chunk&gt; <span class="title">RemoteSource::tryGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// onCancel() will do the cancel if the query was sent.</span></span><br><span class="line">    <span class="keyword">if</span> (was_query_canceled)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!was_query_sent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// Progress method will be called on Progress packet.</span></span><br><span class="line">        query_executor-&gt;<span class="built_in">setProgressCallback</span>([<span class="keyword">this</span>](<span class="keyword">const</span> Progress &amp; value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.total_rows_to_read)</span><br><span class="line">                <span class="built_in">addTotalRowsApprox</span>(value.total_rows_to_read);</span><br><span class="line">            <span class="built_in">progress</span>(value.read_rows, value.read_bytes);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Get rows_before_limit result for remote query from ProfileInfo packet.</span></span><br><span class="line">        query_executor-&gt;<span class="built_in">setProfileInfoCallback</span>([<span class="keyword">this</span>](<span class="keyword">const</span> ProfileInfo &amp; info)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rows_before_limit &amp;&amp; info.<span class="built_in">hasAppliedLimit</span>())</span><br><span class="line">                rows_before_limit-&gt;<span class="built_in">set</span>(info.<span class="built_in">getRowsBeforeLimit</span>());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        query_executor-&gt;<span class="built_in">sendQuery</span>();</span><br><span class="line"></span><br><span class="line">        was_query_sent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Block block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (async_read)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = query_executor-&gt;<span class="built_in">read</span>(read_context);</span><br><span class="line">        <span class="keyword">if</span> (std::holds_alternative&lt;<span class="keyword">int</span>&gt;(res))</span><br><span class="line">        &#123;</span><br><span class="line">            fd = std::get&lt;<span class="keyword">int</span>&gt;(res);</span><br><span class="line">            is_async_state = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Chunk</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is_async_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        block = std::get&lt;Block&gt;(std::<span class="built_in">move</span>(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        block = query_executor-&gt;<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!block)</span><br><span class="line">    &#123;</span><br><span class="line">        query_executor-&gt;<span class="built_in">finish</span>(&amp;read_context);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UInt64 num_rows = block.<span class="built_in">rows</span>();</span><br><span class="line">    <span class="function">Chunk <span class="title">chunk</span><span class="params">(block.getColumns(), num_rows)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (add_aggregation_info)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> info = std::make_shared&lt;AggregatedChunkInfo&gt;();</span><br><span class="line">        info-&gt;bucket_num = block.info.bucket_num;</span><br><span class="line">        info-&gt;is_overflows = block.info.is_overflows;</span><br><span class="line">        chunk.<span class="built_in">setChunkInfo</span>(std::<span class="built_in">move</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类主要封装了query_executor，在work函数（ISource类型的节点重载了work函数，通过tryGenerate函数产生数据）中发送请求，然后通过query_executor-&gt;read读取结果，这里可以是阻塞读或者非阻塞读，阻塞读就很简单了，从connection中读取数据然后组包返回，这里不展开，主要关注下非阻塞读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto res = query_executor-&gt;read(read_context);</span><br></pre></td></tr></table></figure>

<p>这里返回的结果是一个variant&lt;int, block&gt;， 如果本次非阻塞读到了数据，那么走阻塞读的流程，否则会返回connection对应的fd，并将is_async_state设置为TRUE，<strong>在prepare函数中如果看到is_async_state为true就会返回Status::Async：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ISource::Status <span class="title">RemoteSource::prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Check if query was cancelled before returning Async status. Otherwise it may lead to infinite loop.</span></span><br><span class="line">    <span class="keyword">if</span> (was_query_canceled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getPort</span>().<span class="built_in">finish</span>();</span><br><span class="line">        <span class="keyword">return</span> Status::Finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_async_state)</span><br><span class="line">        <span class="keyword">return</span> Status::Async;</span><br><span class="line"></span><br><span class="line">    Status status = ISource::<span class="built_in">prepare</span>();</span><br><span class="line">    <span class="comment">/// To avoid resetting the connection (because of &quot;unfinished&quot; query) in the</span></span><br><span class="line">    <span class="comment">/// RemoteQueryExecutor it should be finished explicitly.</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status::Finished)</span><br><span class="line">    &#123;</span><br><span class="line">        query_executor-&gt;<span class="built_in">finish</span>(&amp;read_context);</span><br><span class="line">        is_async_state = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看下query_executor-&gt;read(read_context)这个函数，这部分内容其实和调度引擎关系不大，没有特别需求的读者可以将其当做个黑盒子，跳过这部分内容。</p>
<p>ClickHouse使用第三方库<em>Poco</em>进行开发，其中包括网络库，下面的内容涉及<strong>到通过一个有栈协程衔接了pipeline执行引擎和*Poco::Net*库*。*</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::variant&lt;Block, <span class="keyword">int</span>&gt; <span class="title">RemoteQueryExecutor::read</span><span class="params">(std::unique_ptr&lt;ReadContext&gt; &amp; read_context [[maybe_unused]])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_LINUX)</span></span><br><span class="line">    <span class="keyword">if</span> (!sent_query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sendQuery</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;<span class="built_in">getSettingsRef</span>().skip_unavailable_shards &amp;&amp; (<span class="number">0</span> == connections-&gt;<span class="built_in">size</span>()))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Block</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!read_context || resent_query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(was_cancelled_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (was_cancelled)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">        read_context = std::make_unique&lt;ReadContext&gt;(*connections);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!read_context-&gt;<span class="built_in">resumeRoutine</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read_context-&gt;is_read_in_progress.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">        &#123;</span><br><span class="line">            read_context-&gt;<span class="built_in">setTimer</span>();</span><br><span class="line">            <span class="keyword">return</span> read_context-&gt;epoll.<span class="built_in">getFileDescriptor</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// We need to check that query was not cancelled again,</span></span><br><span class="line">            <span class="comment">/// to avoid the race between cancel() thread and read() thread.</span></span><br><span class="line">            <span class="comment">/// (since cancel() thread will steal the fiber and may update the packet).</span></span><br><span class="line">            <span class="keyword">if</span> (was_cancelled)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> data = <span class="built_in">processPacket</span>(std::<span class="built_in">move</span>(read_context-&gt;packet)))</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">move</span>(*data);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (got_duplicated_part_uuids)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">restartQueryWithoutDuplicatedUUIDs</span>(&amp;read_context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要关注ReadContext，首先调用read_context-&gt;resumeRoutine()，然后检测了一个flag：is_read_in_progress，如果这个flag为true，则说明本次非阻塞读没有读到数据，返回fd，否则就组包返回。</p>
<p>我们看下ReadContext的实现细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RemoteQueryExecutorReadContext::<span class="built_in">RemoteQueryExecutorReadContext</span>(IConnections &amp; connections_)</span><br><span class="line">    : <span class="built_in">connections</span>(connections_)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">pipe2</span>(pipe_fd, O_NONBLOCK))</span><br><span class="line">        <span class="built_in">throwFromErrno</span>(<span class="string">&quot;Cannot create pipe&quot;</span>, ErrorCodes::CANNOT_OPEN_FILE);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        epoll.<span class="built_in">add</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        epoll.<span class="built_in">add</span>(timer.<span class="built_in">getDescriptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> routine = RemoteQueryExecutorRoutine&#123;connections, *<span class="keyword">this</span>&#125;;</span><br><span class="line">    fiber = boost::context::<span class="built_in">fiber</span>(std::<span class="built_in">allocator_arg_t</span>(), stack, std::<span class="built_in">move</span>(routine));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中构造了一个fiber协程RemoteQueryExecutorRoutine：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoteQueryExecutorRoutine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IConnections &amp; connections;</span><br><span class="line">    RemoteQueryExecutorReadContext &amp; read_context;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ReadCallback</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        RemoteQueryExecutorReadContext &amp; read_context;</span><br><span class="line">        Fiber &amp; fiber;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> fd, Poco::Timespan timeout = <span class="number">0</span>, <span class="keyword">const</span> std::string fd_description = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                read_context.<span class="built_in">setConnectionFD</span>(fd, timeout, fd_description);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in"><span class="keyword">catch</span></span> (DB::Exception &amp; e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.<span class="built_in">addMessage</span>(<span class="string">&quot; while reading from &#123;&#125;&quot;</span>, fd_description);</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read_context.is_read_in_progress.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">            fiber = std::<span class="built_in">move</span>(fiber).<span class="built_in">resume</span>();</span><br><span class="line">            read_context.is_read_in_progress.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Fiber <span class="title">operator</span><span class="params">()</span><span class="params">(Fiber &amp;&amp; sink)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                read_context.packet = connections.<span class="built_in">receivePacketUnlocked</span>(ReadCallback&#123;read_context, sink&#125;, <span class="literal">false</span> <span class="comment">/* is_draining */</span>);</span><br><span class="line">                sink = std::<span class="built_in">move</span>(sink).<span class="built_in">resume</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> boost::context::detail::forced_unwind &amp;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// This exception is thrown by fiber implementation in case if fiber is being deleted but hasn&#x27;t exited</span></span><br><span class="line">            <span class="comment">/// It should not be caught or it will segfault.</span></span><br><span class="line">            <span class="comment">/// Other exceptions must be caught</span></span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            read_context.exception = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(sink);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后看下函数resumeRoutine()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RemoteQueryExecutorReadContext::resumeRoutine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_read_in_progress.<span class="built_in">load</span>(std::memory_order_relaxed) &amp;&amp; !<span class="built_in">checkTimeout</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">guard</span><span class="params">(fiber_lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!fiber)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        fiber = std::<span class="built_in">move</span>(fiber).<span class="built_in">resume</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，每次调用resumeRoutine()，都是在推动这个协程继续执行，协程中的逻辑是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    read_context.packet = connections.<span class="built_in">receivePacketUnlocked</span>(ReadCallback&#123;read_context, sink&#125;, <span class="literal">false</span> <span class="comment">/* is_draining */</span>);</span><br><span class="line">    sink = std::<span class="built_in">move</span>(sink).<span class="built_in">resume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connections.receivePacketUnlocked的逻辑是：进行非阻塞读，如果读到数据就返回，否则调用ReadCallback。（这个逻辑很重要）</p>
<p>ReadCallback的逻辑是：拿到fd，并设置is_read_in_progress为TRUE，然后切回resumeRoutine函数执行。（这个逻辑也很重要）</p>
<p>下面总结一下这里的执行流程，首先看非阻塞读读到数据的情况：</p>
<ul>
<li>RemoteSource::tryGenerate() 调用</li>
<li>query_executor-&gt;read(read_context) 调用</li>
<li>read_context-&gt;resumeRoutine() 切换到协程RemoteQueryExecutorRoutine执行</li>
<li>read_context.packet = connections.receivePacketUnlocked读到数据，切回read_context-&gt;resumeRoutine()执行</li>
<li>检查is_read_in_progress，为false，组包返回。</li>
<li>RemoteSource拿到数据，传递给下游节点。</li>
</ul>
<p>接着看下非阻塞读没读到数据的情况：</p>
<ul>
<li>RemoteSource::tryGenerate() 调用</li>
<li>query_executor-&gt;read(read_context) 调用</li>
<li>read_context-&gt;resumeRoutine() 切换到协程RemoteQueryExecutorRoutine执行</li>
<li>read_context.packet = connections.receivePacketUnlocked没读到数据，调用ReadCallback</li>
<li>ReadCallback中设置is_read_in_progress为true，切回read_context-&gt;resumeRoutine()执行</li>
<li>检查is_read_in_progress为true，返回fd</li>
<li>RemoteSource拿到fd，设置is_async_state = false，下次prepare函数调用时返回Status::Async</li>
<li>执行引擎使用epoll检测fd，可读时将RemoteSource节点push到工作线程上下文并唤醒工作线程</li>
<li>工作线程从上下文中获得RemoteSource节点，调用work函数（tryGenerate）</li>
<li>query_executor-&gt;read(read_context) 调用</li>
<li>read_context-&gt;resumeRoutine() 切换到协程RemoteQueryExecutorRoutine执行，此时这个协程的suspend point实际上是在ReadCallback中，is_read_in_progress设置为false。</li>
<li>connections继续非阻塞读，如果<strong>还是没读到，会再次调用ReadCallback，重复上述流程。</strong>一般情况这里是可读的，因为epoll检测到了fd上的可读事件。connections读到数据，receivePacketUnlocked函数返回，设置read_context.packet，然后切回read_context-&gt;resumeRoutine()执行</li>
<li>检查is_read_in_progress为false，调用processPacket(std::move(read_context-&gt;packet))组包返回</li>
<li>RemoteSource拿到数据，传递给下游节点。</li>
</ul>
<p>总结：这部分内容，你说它不重要吧，它衔接了执行引擎和网络库，使得执行引擎支持异步网络io；你说它重要吧，它又是一些胶水代码，为早期网络库的选择擦屁股，多了很多不必要的逻辑，大大增加了阅读和理解成本，还容易出错。</p>
<p>对于这种体量的项目，一些基础模块还是自己开发比较好，封装网络库的工作量并不会太大（仅项目使用，不需要为了通用性买太多单），也可以根据需求灵活的调整各种姿势。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528514990">Push还是Pull，这是个问题么？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://link.zhihu.com/?target=https://presentations.clickhouse.com/meetup24/5.%20Clickhouse%20query%20execution%20pipeline%20changes/%23clickhouse-query-execution-pipeline">ClickHouse Query Execution Pipeline</a></p>
<p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/B_e_a_u_tiful1205/article/details/103537034">ClickHouse源码阅读(0000 0100) —— ClickHouse是如何执行SQL的_B_e_a_u_tiful1205的博客-CSDN博客</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/clickhouse/" rel="tag"><i class="fa fa-tag"></i> clickhouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/19/ClickHouse%E4%B9%8B%E8%81%9A%E5%90%88%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="ClickHouse之聚合功能源码分析">
      <i class="fa fa-chevron-left"></i> ClickHouse之聚合功能源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/17/clickhouse-storage/" rel="next" title="Clickhouse storage 101">
      Clickhouse storage 101 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EPipelineExecutor"><span class="nav-number">2.</span> <span class="nav-text">关于PipelineExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85PipelineExecutor"><span class="nav-number">3.</span> <span class="nav-text">封装PipelineExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Status-Async%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E4%B8%8E%E7%BD%91%E7%BB%9Cio%E7%9A%84%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5"><span class="nav-number">4.</span> <span class="nav-text">Status::Async，执行引擎与网络io的无缝衔接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipeline%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E8%A7%86%E8%A7%92"><span class="nav-number">4.1.</span> <span class="nav-text">Pipeline执行引擎的视角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RemoteSource%EF%BC%88%E9%80%89%E8%AF%BB%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">RemoteSource（选读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.3.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tao"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">Tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aaaaaaron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aaaaaaron" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tao@apache.org" title="E-Mail → mailto:tao@apache.org" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a>
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
