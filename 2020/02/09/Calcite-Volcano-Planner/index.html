<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://aaaaaaron.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: false,
    comments: {"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="优化器模型介绍Cascade&#x2F;VolcanoCalcite Volcano Planner 的思想来自 Cascade&#x2F;Volcano采用自顶向下的动态规划算法（记忆化搜索） Volcano Optimizer 将搜索分为两个阶段，在第一个阶段枚举所有逻辑等价的 Logical Algebra，而在第二阶段运用动态规划的方法自顶向下地搜索代价最小的 Physical Algebra Cascade">
<meta property="og:type" content="article">
<meta property="og:title" content="Calcite Volcano Planner">
<meta property="og:url" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/index.html">
<meta property="og:site_name" content="Jiatao Tao&#39;s blog">
<meta property="og:description" content="优化器模型介绍Cascade&#x2F;VolcanoCalcite Volcano Planner 的思想来自 Cascade&#x2F;Volcano采用自顶向下的动态规划算法（记忆化搜索） Volcano Optimizer 将搜索分为两个阶段，在第一个阶段枚举所有逻辑等价的 Logical Algebra，而在第二阶段运用动态规划的方法自顶向下地搜索代价最小的 Physical Algebra Cascade">
<meta property="og:locale">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208221706543.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208221734549.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208221741219.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208225453064-20210507205155192.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200201142854598.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200130143902228.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200201143344730.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200130235141251.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208225742683.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208225746328.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200131214015824.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200131214114884.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200131224924660.png">
<meta property="article:published_time" content="2020-02-09T12:49:53.000Z">
<meta property="article:modified_time" content="2021-05-07T16:38:40.848Z">
<meta property="article:author" content="Jiatao Tao">
<meta property="article:tag" content="BigData">
<meta property="article:tag" content="Calcite">
<meta property="article:tag" content="OLAP">
<meta property="article:tag" content="Optimizer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/image-20200208221706543.png">

<link rel="canonical" href="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Calcite Volcano Planner | Jiatao Tao's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jiatao Tao's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">λ</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-desktop"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Jiatao Tao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiatao Tao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Calcite Volcano Planner
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-09 20:49:53" itemprop="dateCreated datePublished" datetime="2020-02-09T20:49:53+08:00">2020-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-08 00:38:40" itemprop="dateModified" datetime="2021-05-08T00:38:40+08:00">2021-05-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/02/09/Calcite-Volcano-Planner/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/09/Calcite-Volcano-Planner/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="优化器模型介绍"><a href="#优化器模型介绍" class="headerlink" title="优化器模型介绍"></a>优化器模型介绍</h1><h2 id="Cascade-Volcano"><a href="#Cascade-Volcano" class="headerlink" title="Cascade/Volcano"></a>Cascade/Volcano</h2><p>Calcite Volcano Planner 的思想来自 Cascade/Volcano<br>采用自顶向下的动态规划算法（记忆化搜索）</p>
<p>Volcano Optimizer 将搜索分为两个阶段，在第一个阶段枚举所有逻辑等价的 Logical Algebra，而在第二阶段运用动态规划的方法自顶向下地搜索代价最小的 Physical Algebra</p>
<p>Cascades Optimizer 则将这两个阶段融合在一起，通过提供一个 Guidance 来指导 Rule 的执行顺序，在枚举逻辑等价算子的同时也进行物理算子的生成，这样做可以避免枚举所有的逻辑执行计划</p>
<p><strong>Memo</strong></p>
<p>Cascades Optimizer 在搜索的过程中，其搜索的空间</p>
<ul>
<li>MEMO 的定义：是一种数据结构，用于管理一个组，每个组代表一个查询计划的不同子目标。</li>
<li>MEMO 结构的目标：是通过尽可能的公用相同的子树使得内存的使用最小。</li>
<li>MEMO 的主要思想：通过使用共享的副本来避免子树的重复使用。</li>
</ul>
<p><strong>Rule</strong><br>Volcano/Cascade Optimizer 中的变化都使用 Rule 来描述:</p>
<ul>
<li>Logical Algebra 之间的转换使用 Transformation Rule；</li>
<li>Logical Algebra 到 Physical Algebra 之间的转换使用 Implementation Rule</li>
<li>Physical Property 可以从 Physical Algebra 中提取，表示算子所产生的数的具有的物理属性，比如按照某个 Key 排序、按照某个 Key 分布在集群中等</li>
</ul>
<p>Memo 中两个最基本的概念就是 Expression Group（简称 Group） 以及 Group Expression（对应关系代数算子）</p>
<ul>
<li>每个 Group 中保存的是逻辑等价的 Group Expression</li>
<li>Group Expression 的子节点是由 Group 组成</li>
</ul>
<h3 id="Init-Memo"><a href="#Init-Memo" class="headerlink" title="Init Memo"></a>Init Memo</h3><p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208221706543.png" alt="image-20200208221706543"></p>
<p>一旦最初的计划复制到了MEMO结构中以后，就可以对逻辑操作符做一些转换以生成物理操作符。</p>
<p>一个转换规则可以生成：</p>
<ol>
<li>同一组中的一个逻辑操作符: 如 join( A, B) -&gt; join( B, A)</li>
<li>同一组中的一个物理操作符: 如 join -&gt; Hash Join</li>
</ol>
<p>一组逻辑操作符组成一个子计划。根仍保留在原来的组中，而其他操作符分配到其他的组中，必要的时候可以建立新组，如 join( A, join(B,C)) -&gt; join( join(A,B), C), 这两个最外面的 Join 是等价的, 所以是同一个根节点, 但是前后两次里面的 join 不一样, 所以在不同的组</p>
<h3 id="Apply-transformation-implement-rule"><a href="#Apply-transformation-implement-rule" class="headerlink" title="Apply transformation/implement rule"></a>Apply transformation/implement rule</h3><p>由于物理属性的不同，同一组中的某些操作符可作为孩子节点，而另外一些操作符则不能</p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208221734549.png" alt="image-20200208221734549"></p>
<h3 id="Find-best-plan"><a href="#Find-best-plan" class="headerlink" title="Find best plan"></a>Find best plan</h3><p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208221741219.png" alt="image-20200208221741219"></p>
<p><strong>Ref:</strong></p>
<p>[1]. [图片] Counting, Enumerating, and Sampling of Execution Plans in a Cost-Based Query Optimizer</p>
<p>[2]. The Cascades Framework for Query Optimization</p>
<p>[3]. Orca: A Modular Query Optimizer Architecture for Big Data</p>
<h1 id="Calcite-Volcano-Planner"><a href="#Calcite-Volcano-Planner" class="headerlink" title="Calcite Volcano Planner"></a>Calcite Volcano Planner</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p><strong>RelNode</strong>: Relation Expression, 逻辑执行计划的节点.</p>
<ul>
<li><p>继承自 RelOptNode, 代表可以被优化器优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 RelNode 都有对应的 RelTraitSet 来描述其物理特性</span></span><br><span class="line">  <span class="keyword">protected</span> RelTraitSet traitSet;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其 children</span></span><br><span class="line">  <span class="function">List&lt;RelNode&gt; <span class="title">getInputs</span><span class="params">()</span></span>;</span><br><span class="line">&lt;!--￼<span class="number">0</span>--&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>RelTrait:</p>
<ul>
<li>RelTrait 是对应 RelTraitDef 的具体实例, 需要关注的是可以 register 方法来添加注册相关的 Rule(但是只有 JdbcConvention 一个实现了这个方法)</li>
<li>代表 Convention/排序/分布, Convention下面会详细解释.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(RelOptPlanner planner)</span></span>;</span><br><span class="line"><span class="function">RelTraitDef <span class="title">getTraitDef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">satisfies</span><span class="params">(RelTrait trait)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>RelTraitDef:</p>
<ul>
<li><p>类定义: <code>public abstract class RelTraitDef&lt;T extends RelTrait&gt;</code></p>
</li>
<li><p>定义一类 <code>RelTrait</code>, 有三类 (ConventionTraitDef/RelCollationTraitDef/RelDistributionTraitDef)</p>
</li>
<li><p>主要有两个方法 <code>convert()</code>/ <code>canConvert()</code>:</p>
<ul>
<li><p><code>canConvert</code> 和 <code>RelTrait#satisfies</code>, 没搞懂为啥要搞两套.</p>
<ul>
<li>e.g. Collation 的 <code>convert</code> 实现则是添加一个 <code>LogicalSort</code> 的 Rel 来替换原始 Rel 达到替换输出 trait 的目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>ConventionTraitDef<ul>
<li><strong>代表一个物理实现, 为了方便异构数据源(database backend)混合查询, .</strong></li>
</ul>
</li>
<li>RelCollationTraitDef (排序)</li>
<li>RelDistributionTraitDef (分布)</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>RelSet</strong>: 描述一组逻辑上相等的 RelNode 的集合</p>
<ul>
<li>没有父类, 不是 **RelNode **!</li>
<li>所有的等价的 RelNode 会记录在 <code>rels</code> 中</li>
<li>一组等价关系表达式的集合, 语义相同, 但是其中的 RelNode 可以有不同的 Trait.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;RelNode&gt; rels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> List&lt;RelNode&gt; parents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> List&lt;RelSubset&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List of &#123;<span class="doctag">@link</span> AbstractConverter&#125; objects which have not yet been</span></span><br><span class="line"><span class="comment"> * satisfied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> List&lt;AbstractConverter&gt; abstractConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>RelSubset</strong>: 描述一组物理上相等的 Relation Expression，即具有相同的 Physical Properties</p>
<ul>
<li>也是一种 <strong>RelNode, 不是 RelSet !!!</strong></li>
<li>在一个 RelSet 中相同的 RelTraitSet 的 RelNode 会在同一个 RelSubSet 内</li>
<li>添加一个 Rel 到 RelSubset 会添加 rel 到对应的 RelSet 中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * cost of best known plan (it may have improved since)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> RelOptCost bestCost;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The set this subset belongs to.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> RelSet set;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * best known plan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> RelNode best;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span> RelTraitSet traitSet;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Iterable&lt;RelNode&gt; <span class="title">getRels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> () -&gt; Linq4j.asEnumerable(set.rels)</span><br><span class="line">       .where(v1 -&gt; v1.getTraitSet().satisfies(traitSet))</span><br><span class="line">       .iterator();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个 RelSet 有一组 RelSubset, 而一个 RelSubset 引用一个 RelSet.</li>
<li>一个 RelSet 可能有多种 trait (因为一组 RelNode 逻辑上等价, 物理上(trait) 不等价), 比如 在 [X] , [Y, Z] 上都进行了排序, 那么对于这个 RelSet 有两个 RelSubset</li>
<li>通过 getRels 符合自己 trait 的 rels.</li>
</ul>
</li>
<li><p><strong>VolcanoRuleMatch/RuleCall</strong> :描述一次成功规则的匹配，包含 Rule 和被匹配的节点</p>
</li>
<li><p><strong>RuleQueue</strong>:是一个优先队列，包含当前所有可行的 RuleMatch</p>
</li>
<li><p><strong>Importance</strong> :描述 RuleMatch 的重要程度，importance 大的优先处理, 每一轮迭代都会实时调整.</p>
<ul>
<li><ul>
<li>尽量对代价大的节点先做优化，从而尽可能在有限的优化次数内获得更大的收益, ost 越大、importance 也越大</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Program</strong>: 用来组装优化的流程, 类似 pipeline 的感觉.</p>
</li>
</ul>
<h4 id="调用约定概念梳理"><a href="#调用约定概念梳理" class="headerlink" title="调用约定概念梳理"></a>调用约定概念梳理</h4><p>Calite 的特有概念, 为了支持多数据源(异构数据源)</p>
<h5 id="Convention"><a href="#Convention" class="headerlink" title="Convention"></a>Convention</h5><ul>
<li><p>一种 RelTrait, <strong>表一个物理实现</strong></p>
</li>
<li><p>几种实现</p>
<ol>
<li>Convention#Impl: 默认的 Convention, 只是提供了接口信息和名称信息 e.g.</li>
</ol>
<ul>
<li><code>Convention NONE = new Impl(&quot;NONE&quot;, RelNode.class);</code></li>
<li><code>SparkRel.CONVENTION: new Convention.Impl(&quot;SPARK&quot;, SparkRel.class);</code></li>
</ul>
<ol>
<li><p>EnumerableConvention: 能返回 <code>linq4j.Enumerable</code> 的 Convention 实现, 默认一般用这个, 会使用 codegen.</p>
</li>
<li><p>InterpretableConvention: 也是返回 Enumerable, 同样会实现 EnumerableRel 接口, 不通过 codegen 执行</p>
</li>
<li><p>JdbcConvention,</p>
</li>
<li><p>BindableConvention</p>
</li>
</ol>
</li>
</ul>
<h5 id="ConverterRule"><a href="#ConverterRule" class="headerlink" title="ConverterRule:"></a>ConverterRule:</h5><ul>
<li>是 RelOptRule 的子类, 专门用来做数据源之间的转换</li>
<li>ConverterRule 一般会调用对应的 Converter 来完成工作, 比如说 JdbcToSparkConverterRule 调用 JdbcToSparkConverter 来完成对 JDBC Table 到 Spark RDD 的转换</li>
<li>Abstract base class for a rule which converts from one calling convention to another without changing semantics.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Planner rule that converts from Spark to enumerable convention. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SparkToEnumerableConverterRule</span> <span class="keyword">extends</span> <span class="title">ConverterRule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SparkToEnumerableConverterRule INSTANCE =</span><br><span class="line">      <span class="keyword">new</span> SparkToEnumerableConverterRule();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SparkToEnumerableConverterRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(</span><br><span class="line">        RelNode.class, SparkRel.CONVENTION, EnumerableConvention.INSTANCE,</span><br><span class="line">        <span class="string">&quot;SparkToEnumerableConverterRule&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RelNode <span class="title">convert</span><span class="params">(RelNode rel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SparkToEnumerableConverter(rel.getCluster(),</span><br><span class="line">        rel.getTraitSet().replace(EnumerableConvention.INSTANCE), rel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Converter"><a href="#Converter" class="headerlink" title="Converter:"></a>Converter:</h5><ul>
<li>一种特殊的 RelNode (<strong>这是一个 RelNode</strong>)</li>
<li>后续用 ExpandConversionRule 来调用 TraitDef 的 convert 来做转换, 关于 convention, 需要 isGuaranteed 为 true, 但是在 calcite 代码里并没有这个转换, 其他使用 Calcite 的引擎有, 如 Drill.</li>
<li>由 Converter Rule 转化而成</li>
<li>举个例子: <code>SparkToEnumerableConverterRule</code> 实现了 <code>SparkRel.CONVENTION</code> 到 <code>EnumerableConvention</code> 的转换，生成了<code>SparkToEnumerableConverter</code> , 对应没有这一套是会生成一个<code>AbstractConverter</code> 在根节点, 所以他们的子节点的 trait (Convention) 会以他们为准(ENUMERABLE/SPARK).</li>
<li>再次强调这个 <code>SparkToEnumerableConverter</code> 是一个 RelNode, 可以看看这个节点怎么生成物理执行计划:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">implement</span><span class="params">(EnumerableRelImplementor implementor, Prefer pref)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Generate:</span></span><br><span class="line">  <span class="comment">//   RDD rdd = ...;</span></span><br><span class="line">  <span class="comment">//   return SparkRuntime.asEnumerable(rdd);</span></span><br><span class="line">  <span class="keyword">final</span> BlockBuilder list = <span class="keyword">new</span> BlockBuilder();</span><br><span class="line">  <span class="keyword">final</span> SparkRel child = (SparkRel) getInput();</span><br><span class="line">  <span class="keyword">final</span> PhysType physType =</span><br><span class="line">      PhysTypeImpl.of(implementor.getTypeFactory(),</span><br><span class="line">          getRowType(),</span><br><span class="line">          JavaRowFormat.CUSTOM);</span><br><span class="line">  SparkRel.Implementor sparkImplementor =</span><br><span class="line">      <span class="keyword">new</span> SparkImplementorImpl(implementor);</span><br><span class="line">  <span class="keyword">final</span> SparkRel.Result result = child.implementSpark(sparkImplementor);</span><br><span class="line">  <span class="keyword">final</span> Expression rdd = list.append(<span class="string">&quot;rdd&quot;</span>, result.block);</span><br><span class="line">  <span class="keyword">final</span> Expression enumerable =</span><br><span class="line">      list.append(</span><br><span class="line">          <span class="string">&quot;enumerable&quot;</span>,</span><br><span class="line">          Expressions.call(</span><br><span class="line">              SparkMethod.AS_ENUMERABLE.method,</span><br><span class="line">              rdd));</span><br><span class="line">  list.add(Expressions.return_(<span class="keyword">null</span>, enumerable));</span><br><span class="line">  <span class="keyword">return</span> implementor.result(physType, list.toBlock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SparkMethod.AS_ENUMERABLE.method</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS_ENUMERABLE(SparkRuntime.class, <span class="string">&quot;asEnumerable&quot;</span>, JavaRDD.class)</span><br></pre></td></tr></table></figure>

<p>在 SparkRuntime 类中可以找到 asEnumerable 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Converts an RDD into an enumerable. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Enumerable&lt;T&gt; <span class="title">asEnumerable</span><span class="params">(JavaRDD&lt;T&gt; rdd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Linq4j.asEnumerable(rdd.collect());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208225453064-20210507205155192.png" alt="image-20200208225453064"></p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><p><strong>测试 SQL: select * from emps where name = ‘John’</strong></p>
<p><strong>1. Prepare</strong></p>
<p>看代码中最后的 return 语句, 加进来了一系列的优化:</p>
<ol>
<li>Hep Planner 做一些子查询的优化 (SubQueryRemoveRule.FILTER, SubQueryRemoveRule.PROJECT, SubQueryRemoveRule.JOIN)</li>
<li>DecorrelateProgram/TrimFieldsProgram</li>
<li><strong>Volcano Planner</strong>, 默认会注册一些 rule, 在 RelOptUtil#registerDefaultRules</li>
<li>Hep Planner# RelOptRules.CALC_RULES</li>
</ol>
<p>对 VolcanoPlanner 的使用就是在第3步, 我们主要关注这一步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RelRoot <span class="title">optimize</span><span class="params">(RelRoot root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Program program = getProgram();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> RelNode rootRel4 = program.run(planner, root.rel, desiredTraits, materializationList, latticeList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Program <span class="title">standard</span><span class="params">(RelMetadataProvider metadataProvider)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Program program1 =</span><br><span class="line">      (planner, rel, requiredOutputTraits, materializations, lattices) -&gt; &#123;</span><br><span class="line">        planner.setRoot(rel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RelOptMaterialization materialization : materializations) &#123;</span><br><span class="line">          planner.addMaterialization(materialization);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RelOptLattice lattice : lattices) &#123;</span><br><span class="line">          planner.addLattice(lattice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RelNode rootRel2 =</span><br><span class="line">            rel.getTraitSet().equals(requiredOutputTraits)</span><br><span class="line">                ? rel</span><br><span class="line">                : planner.changeTraits(rel, requiredOutputTraits);</span><br><span class="line">        <span class="keyword">assert</span> rootRel2 != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        planner.setRoot(rootRel2);</span><br><span class="line">        <span class="keyword">final</span> RelOptPlanner planner2 = planner.chooseDelegate();</span><br><span class="line">        <span class="keyword">final</span> RelNode rootRel3 = planner2.findBestExp();</span><br><span class="line">        <span class="keyword">assert</span> rootRel3 != <span class="keyword">null</span> : <span class="string">&quot;could not implement exp&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> rootRel3;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sequence(subQuery(metadataProvider),</span><br><span class="line">      <span class="keyword">new</span> DecorrelateProgram(),</span><br><span class="line">      <span class="keyword">new</span> TrimFieldsProgram(),</span><br><span class="line">      program1,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Second planner pass to do physical &quot;tweaks&quot;. This the first time</span></span><br><span class="line">      <span class="comment">// that EnumerableCalcRel is introduced.</span></span><br><span class="line">      calc(metadataProvider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-default-rule-trait"><a href="#set-default-rule-trait" class="headerlink" title="set default rule/trait"></a>set default rule/trait</h3><p><strong>CalcitePrepareImpl#createPlanner</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> VolcanoPlanner planner = <span class="keyword">new</span> VolcanoPlanner(costFactory, externalContext);</span><br><span class="line"></span><br><span class="line">planner.addRelTraitDef(ConventionTraitDef.INSTANCE);</span><br><span class="line"><span class="keyword">if</span> (CalciteSystemProperty.ENABLE_COLLATION_TRAIT.value()) &#123;</span><br><span class="line">  planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RelOptUtil.registerDefaultRules(planner,prepareContext.config().materializationsEnabled(), enableBindable);</span><br></pre></td></tr></table></figure>

<p>VolcanoPlanner#addRule</p>
<ul>
<li>RelOptRuleOperand<ul>
<li>e.g. Join(Filter, Any)</li>
</ul>
</li>
</ul>
<p>在优化时，哪个 RelNode 可以应用哪些 Rule 都已经提前记录好了, 是一个 MultiMap，一个<strong>RelNode</strong>可以对应于多个 operands.</p>
<p>后面还会调用 rule 的 onMatch 进行筛选, 这里只是很粗粒度的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each of this rule&#x27;s operands is an &#x27;entry point&#x27; for a rule call.</span></span><br><span class="line"><span class="comment">// Register each operand against all concrete sub-classes that could match it.</span></span><br><span class="line"><span class="keyword">for</span> (RelOptRuleOperand operand : rule.getOperands()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;? extends RelNode&gt; subClass: subClasses(operand.getMatchedClass())) &#123;</span><br><span class="line">    classOperands.put(subClass, operand);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>match 的具体位置在:</p>
<p>org.apache.calcite.plan.volcano.VolcanoRuleCall#matchRecurse</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (getRule().matches(<span class="keyword">this</span>)) &#123;</span><br><span class="line">  onMatch();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="setRoot-1st"><a href="#setRoot-1st" class="headerlink" title="setRoot (1st)"></a>setRoot (1st)</h3><p>初始进入 optimizer 时的执行计划的 dump plan:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LogicalProject(EMPNO<span class="operator">=</span>[$<span class="number">0</span>], NAME<span class="operator">=</span>[$<span class="number">1</span>], DEPTNO<span class="operator">=</span>[$<span class="number">2</span>], GENDER<span class="operator">=</span>[$<span class="number">3</span>], CITY<span class="operator">=</span>[$<span class="number">4</span>], EMPID<span class="operator">=</span>[$<span class="number">5</span>], AGE<span class="operator">=</span>[$<span class="number">6</span>], SLACKER<span class="operator">=</span>[$<span class="number">7</span>], MANAGER<span class="operator">=</span>[$<span class="number">8</span>], JOINEDAT<span class="operator">=</span>[$<span class="number">9</span>])</span><br><span class="line">  LogicalFilter(<span class="keyword">condition</span><span class="operator">=</span>[<span class="operator">=</span>($<span class="number">1</span>, <span class="string">&#x27;John&#x27;</span>)])</span><br><span class="line">    LogicalTableScan(<span class="keyword">table</span><span class="operator">=</span>[[SALES, EMPS]])</span><br></pre></td></tr></table></figure>

<p>核心方法是 <code>registerImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(RelNode rel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = registerImpl(rel, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.originalRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.originalRoot = rel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Making a node the root changes its importance.</span></span><br><span class="line">  <span class="keyword">this</span>.ruleQueue.recompute(<span class="keyword">this</span>.root);</span><br><span class="line">  ensureRootConverters();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RelSubset <span class="title">registerImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      RelNode rel,</span></span></span><br><span class="line"><span class="params"><span class="function">      RelSet set)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerSubset(set, (RelSubset) rel);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归调用</span></span><br><span class="line">  rel = rel.onRegister(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Place the expression in the appropriate equivalence set.</span></span><br><span class="line">  <span class="keyword">if</span> (set == <span class="keyword">null</span>) &#123;</span><br><span class="line">    set = <span class="keyword">new</span> RelSet(</span><br><span class="line">        nextSetId++,</span><br><span class="line">        Util.minus(</span><br><span class="line">            RelOptUtil.getVariablesSet(rel),</span><br><span class="line">            rel.getVariablesSet()),</span><br><span class="line">        RelOptUtil.getVariablesUsed(rel));</span><br><span class="line">    <span class="keyword">this</span>.allSets.add(set);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// **把 RelNode 加到 RelSet 中, 并且返回一个 RelSubset, 因为新加入的 rel 可能有之前没有过的 trait, 所以可能生成一个新的 RelSubset**</span></span><br><span class="line">  RelSubset subset = addRelToSet(rel, set);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Queue up all rules triggered by this relexp&#x27;s creation.</span></span><br><span class="line">  fireRules(rel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It&#x27;s a new subset.</span></span><br><span class="line">  <span class="keyword">if</span> (set.subsets.size() &gt; subsetBeforeCount) &#123;</span><br><span class="line">    fireRules(subset, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subset;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RelSubset <span class="title">addRelToSet</span><span class="params">(RelNode rel, RelSet set)</span> </span>&#123;</span><br><span class="line">  RelSubset subset = set.add(rel);</span><br><span class="line">  mapRel2Subset.put(rel, subset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While a tree of RelNodes is being registered, sometimes nodes&#x27; costs</span></span><br><span class="line">  <span class="comment">// improve and the subset doesn&#x27;t hear about it. You can end up with</span></span><br><span class="line">  <span class="comment">// a subset with a single rel of cost 99 which thinks its best cost is</span></span><br><span class="line">  <span class="comment">// 100. We think this happens because the back-links to parents are</span></span><br><span class="line">  <span class="comment">// not established. So, give the subset another chance to figure out</span></span><br><span class="line">  <span class="comment">// its cost.</span></span><br><span class="line">  <span class="keyword">final</span> RelMetadataQuery mq = rel.getCluster().getMetadataQuery();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    subset.propagateCostImprovements(<span class="keyword">this</span>, mq, rel, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (CyclicMetadataException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>onRegister</strong></p>
<p>注意, 这里更新了 RelNode 的 input 为 RelSubSet(ensureRegistered).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RelNode <span class="title">onRegister</span><span class="params">(RelOptPlanner planner)</span> </span>&#123;</span><br><span class="line">  List&lt;RelNode&gt; oldInputs = getInputs();</span><br><span class="line">  List&lt;RelNode&gt; inputs = <span class="keyword">new</span> ArrayList&lt;&gt;(oldInputs.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> RelNode input : oldInputs) &#123;</span><br><span class="line">    RelNode e = planner.ensureRegistered(input, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 更新 input 为 RelSubset</span></span><br><span class="line">    inputs.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  RelNode r = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Util.equalShallow(oldInputs, inputs)) &#123;</span><br><span class="line">    r = copy(getTraitSet(), inputs);</span><br><span class="line">  &#125;</span><br><span class="line">  r.recomputeDigest();</span><br><span class="line">  <span class="keyword">assert</span> r.isValid(Litmus.THROW, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ensureRegistered</strong></p>
<p>输入是两个等价的 RelNode, 返回一个 RelSubset</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RelSubset <span class="title">ensureRegistered</span><span class="params">(RelNode rel, RelNode equivRel)</span> </span>&#123;</span><br><span class="line">  RelSubset result;</span><br><span class="line">  <span class="keyword">final</span> RelSubset subset = getSubset(rel);</span><br><span class="line">  <span class="keyword">if</span> (subset != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (equivRel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> RelSubset equivSubset = getSubset(equivRel);</span><br><span class="line">      <span class="keyword">if</span> (subset.set != equivSubset.set) &#123;</span><br><span class="line">        merge(equivSubset.set, subset.set);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = subset;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = register(rel, equivRel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Checking if tree is valid considerably slows down planning</span></span><br><span class="line">  <span class="comment">// Only doing it if logger level is debug or finer</span></span><br><span class="line">  <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isValid</span><span class="params">(Litmus.THROW)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fireRules</strong></p>
<p>上面的 fireRules deferred 为是 true, 意思就是不立即执行 rule, 可以看到DeferringRuleCall#onMatch 把 VolcanoRuleMatch 扔到了 rule queue 中, 等之后执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireRules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    RelNode rel,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">boolean</span> deferred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RelOptRuleOperand operand : classOperands.get(rel.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (operand.matches(rel)) &#123;</span><br><span class="line">      <span class="keyword">final</span> VolcanoRuleCall ruleCall;</span><br><span class="line">      <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">        ruleCall = <span class="keyword">new</span> DeferringRuleCall(<span class="keyword">this</span>, operand);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ruleCall = <span class="keyword">new</span> VolcanoRuleCall(<span class="keyword">this</span>, operand);</span><br><span class="line">      &#125;</span><br><span class="line">      ruleCall.match(rel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferringRuleCall</span> <span class="keyword">extends</span> <span class="title">VolcanoRuleCall</span> </span>&#123;</span><br><span class="line">  DeferringRuleCall(</span><br><span class="line">      VolcanoPlanner planner,</span><br><span class="line">      RelOptRuleOperand operand) &#123;</span><br><span class="line">    <span class="keyword">super</span>(planner, operand);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Rather than invoking the rule (as the base method does), creates a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> VolcanoRuleMatch&#125; which can be invoked later.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VolcanoRuleMatch match =</span><br><span class="line">        <span class="keyword">new</span> VolcanoRuleMatch(</span><br><span class="line">            volcanoPlanner,</span><br><span class="line">            getOperand0(),</span><br><span class="line">            rels,</span><br><span class="line">            nodeInputs);</span><br><span class="line">    volcanoPlanner.ruleQueue.addMatch(match);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<p>输入是一颗 RelNode 的树， setRoot 是深度遍历, 将每个 RelNode 创建一个 RelSet 和一个包含初始 RelNode 的 RelSubSet, 并且把节点所能执行的 Rule 作为一个 VolcanoRuleCall 放入 RuleQueue. 最终生成的是一颗 RelSet 组成的树(子树在 RelSet.rels (RelNode#getInput), input 是 RelSubSet, RelSubSet 又记录了 RelSet, 以此类推, 构成一棵树)</p>
<img src="/2020/02/09/Calcite-Volcano-Planner/image-20200201142854598.png" alt="image-20200201142854598" style="zoom:50%;">

<h3 id="setRoot-2st"><a href="#setRoot-2st" class="headerlink" title="setRoot (2st)"></a>setRoot (2st)</h3><p>首先会进行 <code>RelNode rootRel2 = planner.changeTraits(rel, requiredOutputTraits)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RelNode <span class="title">changeTraits</span><span class="params">(<span class="keyword">final</span> RelNode rel, RelTraitSet toTraits)</span> </span>&#123;</span><br><span class="line">    RelSubset rel2 = ensureRegistered(rel, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (rel2.getTraitSet().equals(toTraits)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rel2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rel2.set.getOrCreateSubset(rel.getCluster(), toTraits.simplify());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 changeTraits 里会创建一个新的 RelSubset(<code>rel#16:Subset#2.ENUMERABLE.[]</code>) 作为根节点(rootRel2), 但是两者还是同一个 RelSet (因为逻辑语义上没有变化)</p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200130143902228.png" alt="image-20200130143902228"></p>
<p>然后会再用这个 rootRel2 再 set 一次 root: <code>planner.setRoot(rootRel2);</code> 由于这次的根节点是 RelSubset, registerImpl 会走到 <code>registerSubset</code> 中去. 不过会直接返回出来.</p>
<p>接着会执行 <code>ensureRootConverters</code> , 这里发现当root 的traitSet 和 root 的 subset 的 traitSet 不想等的时候, 会添加一个 AbstractConverter 节点. 注意这个 AbstractConverter 是一个 RelNode.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureRootConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Set&lt;RelSubset&gt; subsets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (RelSubset subset : root.set.subsets) &#123;</span><br><span class="line">    <span class="keyword">final</span> ImmutableList&lt;RelTrait&gt; difference = root.getTraitSet().difference(subset.getTraitSet());</span><br><span class="line">    <span class="keyword">if</span> (difference.size() == <span class="number">1</span> &amp;&amp; subsets.add(subset)) &#123;</span><br><span class="line">      register(<span class="keyword">new</span> AbstractConverter(subset.getCluster(), subset,</span><br><span class="line">              difference.get(<span class="number">0</span>).getTraitDef(), root.getTraitSet()), root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会再一次的调用到 registerImpl, 不过这次 RelSet 已经不为空了.</p>
<p>在 registerImpl 中, 当发现节点是 Converter 时, 会尝试把 Converter merge 到其 child 所在是 RelSet 中(<strong>Converters are in the same set as their children.</strong>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RelSubset <span class="title">registerImpl</span><span class="params">(RelNode rel, RelSet set)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Converters are in the same set as their children.</span></span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">    <span class="keyword">final</span> RelNode input = ((Converter) rel).getInput();</span><br><span class="line">    <span class="keyword">final</span> RelSet childSet = getSet(input);</span><br><span class="line">    <span class="keyword">if</span> ((set != <span class="keyword">null</span>) &amp;&amp; (set != childSet) &amp;&amp; (set.equivalentSet == <span class="keyword">null</span>)) &#123;</span><br><span class="line">      LOGGER.trace(<span class="string">&quot;Register #&#123;&#125; &#123;&#125; (and merge sets, because it is a conversion)&quot;</span>, rel.getId(), rel.getDigest());</span><br><span class="line">      merge(set, childSet);</span><br><span class="line">      registerCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      set = childSet;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是经过第二次 set root 之后的树的关系</p>
<img src="/2020/02/09/Calcite-Volcano-Planner/image-20200201143344730.png" alt="image-20200201143344730" style="zoom:50%;">

<p>整个过程 的 log:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">TRACE - new RelSubset#9</span><br><span class="line">TRACE - Register rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS]) in rel#9:Subset#0.NONE.[]</span><br><span class="line">TRACE - Importance of [rel#9:Subset#0.NONE.[]] is 0.0</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [EnumerableTableScanRule] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [BindableTableScanRule] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [TableScanRule] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]</span><br><span class="line">TRACE - new LogicalFilter#10</span><br><span class="line">TRACE - new RelSubset#11</span><br><span class="line">TRACE - Register rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)) in rel#11:Subset#1.NONE.[]</span><br><span class="line">TRACE - Importance of [rel#9:Subset#0.NONE.[]] to its parent [rel#11:Subset#1.NONE.[]] is 0.0 (parent importance=0.0, child cost=1.0E30, parent cost=1.0E30)</span><br><span class="line">TRACE - Importance of [rel#9:Subset#0.NONE.[]] is 0.0</span><br><span class="line">TRACE - Importance of [rel#11:Subset#1.NONE.[]] is 0.0</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [EnumerableFilterRule] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [FilterTableScanRule] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [MaterializedViewJoinRule(Filter)] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [MaterializedViewFilterScanRule] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]</span><br><span class="line">TRACE - new LogicalProject#12</span><br><span class="line">TRACE - new RelSubset#13</span><br><span class="line">TRACE - Register rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9) in rel#13:Subset#2.NONE.[]</span><br><span class="line">TRACE - Importance of [rel#11:Subset#1.NONE.[]] to its parent [rel#13:Subset#2.NONE.[]] is 0.0 (parent importance=0.0, child cost=1.0E30, parent cost=1.0E30)</span><br><span class="line">TRACE - Importance of [rel#11:Subset#1.NONE.[]] is 0.0</span><br><span class="line">TRACE - Importance of [rel#13:Subset#2.NONE.[]] is 0.0</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [EnumerableProjectRule] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9)]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [ProjectRemoveRule] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9)]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [MaterializedViewJoinRule(Project-Filter)] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [ProjectFilterTransposeRule] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]</span><br><span class="line">TRACE - Importance of [rel#13:Subset#2.NONE.[]] is 1.0</span><br><span class="line">TRACE - new LogicalFilter#14</span><br><span class="line">TRACE - Register: rel#14 is equivalent to rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))</span><br><span class="line">TRACE - new LogicalProject#15</span><br><span class="line">TRACE - Register: rel#15 is equivalent to rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9)</span><br><span class="line">TRACE - new RelSubset#16</span><br><span class="line">TRACE - new AbstractConverter#17</span><br><span class="line">TRACE - Register rel#17:AbstractConverter.ENUMERABLE.[](input=RelSubset#13,convention=ENUMERABLE,sort=[]) in rel#16:Subset#2.ENUMERABLE.[]</span><br><span class="line">TRACE - Importance of [rel#13:Subset#2.NONE.[]] to its parent [rel#16:Subset#2.ENUMERABLE.[]] is 0.495 (parent importance=0.5, child cost=1.0E30, parent cost=1.0E30)</span><br><span class="line">TRACE - Importance of [rel#13:Subset#2.NONE.[]] is 0.495</span><br><span class="line">TRACE - Importance of [rel#16:Subset#2.ENUMERABLE.[]] is 1.0</span><br><span class="line">TRACE - OPTIMIZE Rule-match queued: rule [ExpandConversionRule] rels [rel#17:AbstractConverter.ENUMERABLE.[](input=RelSubset#13,convention=ENUMERABLE,sort=[])]</span><br></pre></td></tr></table></figure>

<h2 id="findBestExp"><a href="#findBestExp" class="headerlink" title="findBestExp"></a>findBestExp</h2><p>这里有 4 个 phase, 但是真的有用的只有一个 <code>OPTIMIZE</code> 阶段.</p>
<h3 id="setInitialImportance"><a href="#setInitialImportance" class="headerlink" title="setInitialImportance()"></a>setInitialImportance()</h3><p>从 root 开始, 将 root SubSet 设置 importance 为 1.0, 之后的其他 children SubSet 设置 importance 为 <code>pow(0.9, n)</code>, n 为 children 在的层数. 经过这一步之后的信息, 可以看到 importance 分别为 1, 0.9, 0.81…:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Root: rel#<span class="number">16</span>:Subset#<span class="number">2.</span>ENUMERABLE.[]</span><br><span class="line">Original rel:</span><br><span class="line">LogicalProject(EMPNO=[$<span class="number">0</span>], NAME=[$<span class="number">1</span>], DEPTNO=[$<span class="number">2</span>], GENDER=[$<span class="number">3</span>], CITY=[$<span class="number">4</span>], EMPID=[$<span class="number">5</span>], AGE=[$<span class="number">6</span>], SLACKER=[$<span class="number">7</span>], MANAGER=[$<span class="number">8</span>], JOINEDAT=[$<span class="number">9</span>]): rowcount = <span class="number">15.0</span>, cumulative cost = &#123;<span class="number">130.0</span> rows, <span class="number">351.0</span> cpu, <span class="number">0.0</span> io&#125;, id = <span class="number">7</span></span><br><span class="line">  LogicalFilter(condition=[=($<span class="number">1</span>, <span class="string">&#x27;John&#x27;</span>)]): rowcount = <span class="number">15.0</span>, cumulative cost = &#123;<span class="number">115.0</span> rows, <span class="number">201.0</span> cpu, <span class="number">0.0</span> io&#125;, id = <span class="number">5</span></span><br><span class="line">    LogicalTableScan(table=[[SALES, EMPS]]): rowcount = <span class="number">100.0</span>, cumulative cost = &#123;<span class="number">100.0</span> rows, <span class="number">101.0</span> cpu, <span class="number">0.0</span> io&#125;, id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sets:</span><br><span class="line">Set#<span class="number">0</span>, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">    rel#<span class="number">9</span>:Subset#<span class="number">0.</span>NONE.[], best=<span class="keyword">null</span>, importance=<span class="number">0.7290000000000001</span></span><br><span class="line">        rel#<span class="number">0</span>:LogicalTableScan.NONE.[](table=[SALES, EMPS]), rowcount=<span class="number">100.0</span>, cumulative cost=&#123;inf&#125;</span><br><span class="line">Set#<span class="number">1</span>, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">    rel#<span class="number">11</span>:Subset#<span class="number">1.</span>NONE.[], best=<span class="keyword">null</span>, importance=<span class="number">0.81</span></span><br><span class="line">        rel#<span class="number">10</span>:LogicalFilter.NONE.[](input=RelSubset#<span class="number">9</span>,condition==($<span class="number">1</span>, <span class="string">&#x27;John&#x27;</span>)), rowcount=<span class="number">15.0</span>, cumulative cost=&#123;inf&#125;</span><br><span class="line">Set#<span class="number">2</span>, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">    rel#<span class="number">13</span>:Subset#<span class="number">2.</span>NONE.[], best=<span class="keyword">null</span>, importance=<span class="number">0.9</span></span><br><span class="line">        rel#<span class="number">12</span>:LogicalProject.NONE.[](input=RelSubset#<span class="number">11</span>,EMPNO=$<span class="number">0</span>,NAME=$<span class="number">1</span>,DEPTNO=$<span class="number">2</span>,GENDER=$<span class="number">3</span>,CITY=$<span class="number">4</span>,EMPID=$<span class="number">5</span>,AGE=$<span class="number">6</span>,SLACKER=$<span class="number">7</span>,MANAGER=$<span class="number">8</span>,JOINEDAT=$<span class="number">9</span>), rowcount=<span class="number">15.0</span>, cumulative cost=&#123;inf&#125;</span><br><span class="line">    rel#<span class="number">16</span>:Subset#<span class="number">2.</span>ENUMERABLE.[], best=<span class="keyword">null</span>, importance=<span class="number">1.0</span></span><br><span class="line">        rel#<span class="number">17</span>:AbstractConverter.ENUMERABLE.[](input=RelSubset#<span class="number">13</span>,convention=ENUMERABLE,sort=[]), rowcount=<span class="number">15.0</span>, cumulative cost=&#123;inf&#125;</span><br></pre></td></tr></table></figure>

<p>由于现在还没有一个完整的物理执行计划, 所以整个计划的 best cost 还是 inf.</p>
<h3 id="RuleQueue-popMatch"><a href="#RuleQueue-popMatch" class="headerlink" title="RuleQueue#popMatch"></a>RuleQueue#popMatch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VolcanoRuleMatch match = ruleQueue.popMatch(phase);</span><br><span class="line">match.onMatch();</span><br></pre></td></tr></table></figure>

<p>在初始 RuleQueue 里有 13 个 Rule Match.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule [ExpandConversionRule] rels [rel#17:AbstractConverter.ENUMERABLE.[](input=RelSubset#13,convention=ENUMERABLE,sort=[])]</span><br><span class="line">rule [EnumerableProjectRule(in:NONE,out:ENUMERABLE)] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9)]&quot;</span><br><span class="line">rule [ProjectRemoveRule] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9)]&quot;</span><br><span class="line">rule [ProjectFilterTransposeRule] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]&quot;</span><br><span class="line">rule [MaterializedViewJoinRule(Project-Filter)] rels [rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]&quot;</span><br><span class="line">rule [ReduceExpressionsRule(Filter)] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]&quot;</span><br><span class="line">rule [MaterializedViewFilterScanRule] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]&quot;</span><br><span class="line">rule [FilterTableScanRule] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]&quot;</span><br><span class="line">rule [MaterializedViewJoinRule(Filter)] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]&quot;</span><br><span class="line">rule [EnumerableFilterRule(in:NONE,out:ENUMERABLE)] rels [rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;))]&quot;</span><br><span class="line">rule [TableScanRule] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]&quot;</span><br><span class="line">rule [BindableTableScanRule] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]&quot;</span><br><span class="line">rule [EnumerableTableScanRule(in:NONE,out:ENUMERABLE)] rels [rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS])]&quot;</span><br></pre></td></tr></table></figure>

<p>挑几个 rule 来举例子:</p>
<h4 id="EnumerableProjectRule"><a href="#EnumerableProjectRule" class="headerlink" title="EnumerableProjectRule"></a>EnumerableProjectRule</h4><p>可以看到在 convert 方法中生成了一个 EnumerableProject, 然后 transformTo 了过去.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rule to convert a &#123;<span class="doctag">@link</span> org.apache.calcite.rel.logical.LogicalProject&#125; to an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnumerableProject&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumerableProjectRule</span> <span class="keyword">extends</span> <span class="title">ConverterRule</span> </span>&#123;</span><br><span class="line">  EnumerableProjectRule() &#123;</span><br><span class="line">    <span class="keyword">super</span>(LogicalProject.class,</span><br><span class="line">        (Predicate&lt;LogicalProject&gt;) RelOptUtil::containsMultisetOrWindowedAgg,</span><br><span class="line">        Convention.NONE, EnumerableConvention.INSTANCE,</span><br><span class="line">        RelFactories.LOGICAL_BUILDER, <span class="string">&quot;EnumerableProjectRule&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMatch</span><span class="params">(RelOptRuleCall call)</span> </span>&#123;</span><br><span class="line">    RelNode rel = call.rel(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rel.getTraitSet().contains(inTrait)) &#123;</span><br><span class="line">      <span class="keyword">final</span> RelNode converted = convert(rel);</span><br><span class="line">      <span class="keyword">if</span> (converted != <span class="keyword">null</span>) &#123;</span><br><span class="line">        call.transformTo(converted);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RelNode <span class="title">convert</span><span class="params">(RelNode rel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LogicalProject project = (LogicalProject) rel;</span><br><span class="line">    <span class="keyword">return</span> EnumerableProject.create(</span><br><span class="line">        convert(project.getInput(),</span><br><span class="line">            project.getInput().getTraitSet()</span><br><span class="line">                .replace(EnumerableConvention.INSTANCE)),</span><br><span class="line">        project.getProjects(),</span><br><span class="line">        project.getRowType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Converts a relation expression to a given set of traits, if it does not</span></span><br><span class="line"><span class="comment">   * already have those traits.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rel      Relational expression to convert</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> toTraits desired traits</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a relational expression with the desired traits; never null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RelNode <span class="title">convert</span><span class="params">(RelNode rel, RelTraitSet toTraits)</span> </span>&#123;</span><br><span class="line">    RelOptPlanner planner = rel.getCluster().getPlanner();</span><br><span class="line"></span><br><span class="line">    RelTraitSet outTraits = rel.getTraitSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toTraits.size(); i++) &#123;</span><br><span class="line">      RelTrait toTrait = toTraits.getTrait(i);</span><br><span class="line">      <span class="keyword">if</span> (toTrait != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outTraits = outTraits.replace(i, toTrait);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rel.getTraitSet().matches(outTraits)) &#123;</span><br><span class="line">      <span class="keyword">return</span> rel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> planner.changeTraits(rel, outTraits);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法 <code>transformTo</code> 中可以看到 register 了这个新生成的物理算子(EnumerableProject): <strong>volcanoPlanner.ensureRegistered(rel, rels[0], this)</strong>, 这次第二个参数 equivRel 不是 null 了, 而是 <code>rels[0](LogicalProject)</code>. 在 VolcanoPlanner#register 中会拿到 equivRel 对应的 RelSet, 再走下去就又是上面的 <code>registerImpl</code>, 只不过这时候会有一个 set 传入.</p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200130235141251.png" alt="image-20200130235141251"></p>
<p>这样就把新生成的这个物理算子注册到了原来的 RelSet 树上, 完成了 transform 的过程.</p>
<p>由于有新的算子生成(EnumerableProject), fireRule 会匹配一条新的规则到 ruleQueue 中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE Rule-match queued: rule [ProjectRemoveRule] rels [rel#19:EnumerableProject.ENUMERABLE.[](input= ...]</span><br></pre></td></tr></table></figure>

<p><strong>Before</strong></p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208225742683.png" alt="image-20200208225742683"></p>
<p><strong>After</strong></p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200208225746328.png" alt="image-20200208225746328"></p>
<h4 id="ProjectRemoveRule"><a href="#ProjectRemoveRule" class="headerlink" title="ProjectRemoveRule"></a>ProjectRemoveRule</h4><p>因为查询是 select * , 所以可以直接取出这个 projection.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMatch</span><span class="params">(RelOptRuleCall call)</span> </span>&#123;</span><br><span class="line">  Project project = call.rel(<span class="number">0</span>);</span><br><span class="line">  RelNode stripped = project.getInput();</span><br><span class="line">  ...</span><br><span class="line">  RelNode child = call.getPlanner().register(stripped, project);</span><br><span class="line">  call.transformTo(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个规则直接就把 project 节点的 child 注册到当前 RelSet, 也就是说直接消除了这个 projection, 故这个新的 plan 的 cost 一定会比原来低.</p>
<p><strong>merge</strong>: <code>RelSet merge(RelSet set, RelSet set2)</code>: 合并两个 RelSet.</p>
<p>RelSet#mergeWith(VolcanoPlanner planner, RelSet otherSet)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (RelSubset otherSubset : otherSet.subsets) &#123;</span><br><span class="line">  planner.ruleQueue.subsetImportances.remove(otherSubset);</span><br><span class="line">  RelSubset subset = getOrCreateSubset(</span><br><span class="line">          otherSubset.getCluster(),</span><br><span class="line">          otherSubset.getTraitSet());</span><br><span class="line">  <span class="comment">// collect RelSubset instances, whose best should be changed</span></span><br><span class="line">  <span class="keyword">if</span> (otherSubset.bestCost.isLt(subset.bestCost)) &#123;</span><br><span class="line">    changedSubsets.put(subset, otherSubset.best);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RelNode otherRel : otherSubset.getRels()) &#123;</span><br><span class="line">    planner.reregister(<span class="keyword">this</span>, otherRel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这个 rule 之后, 来看看 root 的 relset 的前后对比, 可以看到在这一层多了一个 logical filter.</p>
<p><strong>before</strong></p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200131214015824.png" alt="image-20200131214015824"></p>
<p><strong>after</strong></p>
<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200131214114884.png" alt="image-20200131214114884"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Root: rel#18:Subset#1.ENUMERABLE.[]</span><br><span class="line">Original rel:</span><br><span class="line">LogicalProject(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], SLACKER=[$7], MANAGER=[$8], JOINEDAT=[$9]): rowcount = 15.0, cumulative cost = &#123;130.0 rows, 351.0 cpu, 0.0 io&#125;, id = 7</span><br><span class="line">  LogicalFilter(condition=[=($1, &#x27;John&#x27;)]): rowcount = 15.0, cumulative cost = &#123;115.0 rows, 201.0 cpu, 0.0 io&#125;, id = 5</span><br><span class="line">    LogicalTableScan(table=[[SALES, EMPS]]): rowcount = 100.0, cumulative cost = &#123;100.0 rows, 101.0 cpu, 0.0 io&#125;, id = 0</span><br><span class="line"></span><br><span class="line">Sets:</span><br><span class="line">Set#0, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">  rel#9:Subset#0.NONE.[], best=null, importance=0.7290000000000001</span><br><span class="line">    rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS]), rowcount=100.0, cumulative cost=&#123;inf&#125;</span><br><span class="line"></span><br><span class="line">Set#1, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">  rel#11:Subset#1.NONE.[], best=null, importance=0.81</span><br><span class="line">    rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">    rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">  rel#18:Subset#1.ENUMERABLE.[], best=null, importance=0.405</span><br><span class="line">    rel#17:AbstractConverter.ENUMERABLE.[](input=RelSubset#11,convention=ENUMERABLE,sort=[]), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">    rel#19:EnumerableProject.ENUMERABLE.[](input=RelSubset#18,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br></pre></td></tr></table></figure>

<h4 id="经过所有规则之后"><a href="#经过所有规则之后" class="headerlink" title="经过所有规则之后:"></a>经过所有规则之后:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Root: rel#18:Subset#1.ENUMERABLE.[]</span><br><span class="line">Original rel:</span><br><span class="line">LogicalProject(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], SLACKER=[$7], MANAGER=[$8], JOINEDAT=[$9]): rowcount = 15.0, cumulative cost = &#123;130.0 rows, 351.0 cpu, 0.0 io&#125;, id = 7</span><br><span class="line">  LogicalFilter(condition=[=($1, &#x27;John&#x27;)]): rowcount = 15.0, cumulative cost = &#123;115.0 rows, 201.0 cpu, 0.0 io&#125;, id = 5</span><br><span class="line">    LogicalTableScan(table=[[SALES, EMPS]]): rowcount = 100.0, cumulative cost = &#123;100.0 rows, 101.0 cpu, 0.0 io&#125;, id = 0</span><br><span class="line"></span><br><span class="line">Sets:</span><br><span class="line">Set#0, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">  rel#9:Subset#0.NONE.[], best=null, importance=0.81</span><br><span class="line">    rel#0:LogicalTableScan.NONE.[](table=[SALES, EMPS]), rowcount=100.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">  rel#22:Subset#0.ENUMERABLE.[], best=rel#27, importance=0.9</span><br><span class="line">    rel#27:EnumerableInterpreter.ENUMERABLE.[](input=RelSubset#26), rowcount=100.0, cumulative cost=&#123;51.0 rows, 51.01 cpu, 0.0 io&#125;</span><br><span class="line">  rel#26:Subset#0.BINDABLE.[], best=rel#25, importance=0.81</span><br><span class="line">    rel#25:BindableTableScan.BINDABLE.[](table=[SALES, EMPS]), rowcount=100.0, cumulative cost=&#123;1.0 rows, 1.01 cpu, 0.0 io&#125;</span><br><span class="line">Set#1, type: RecordType(INTEGER EMPNO, VARCHAR NAME, INTEGER DEPTNO, VARCHAR GENDER, VARCHAR CITY, INTEGER EMPID, INTEGER AGE, BOOLEAN SLACKER, BOOLEAN MANAGER, DATE JOINEDAT)</span><br><span class="line">  rel#11:Subset#1.NONE.[], best=null, importance=0.9</span><br><span class="line">    rel#10:LogicalFilter.NONE.[](input=RelSubset#9,condition==($1, &#x27;John&#x27;)), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">    rel#12:LogicalProject.NONE.[](input=RelSubset#11,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">  rel#18:Subset#1.ENUMERABLE.[], best=rel#30, importance=1.0</span><br><span class="line">    rel#17:AbstractConverter.ENUMERABLE.[](input=RelSubset#11,convention=ENUMERABLE,sort=[]), rowcount=15.0, cumulative cost=&#123;inf&#125;</span><br><span class="line">    rel#19:EnumerableProject.ENUMERABLE.[](input=RelSubset#18,EMPNO=$0,NAME=$1,DEPTNO=$2,GENDER=$3,CITY=$4,EMPID=$5,AGE=$6,SLACKER=$7,MANAGER=$8,JOINEDAT=$9), rowcount=100.0, cumulative cost=&#123;150.5 rows, 1050.505 cpu, 0.0 io&#125;</span><br><span class="line">    rel#23:EnumerableFilter.ENUMERABLE.[](input=RelSubset#22,condition==($1, &#x27;John&#x27;)), rowcount=15.0, cumulative cost=&#123;66.0 rows, 151.01 cpu, 0.0 io&#125;</span><br><span class="line">    rel#30:EnumerableInterpreter.ENUMERABLE.[](input=RelSubset#21), rowcount=100.0, cumulative cost=&#123;50.5 rows, 50.505 cpu, 0.0 io&#125;</span><br><span class="line">  rel#21:Subset#1.BINDABLE.[], best=rel#20, importance=0.9</span><br><span class="line">    rel#20:BindableTableScan.BINDABLE.[](table=[SALES, EMPS],filters=[=($1, &#x27;John&#x27;)]), rowcount=100.0, cumulative cost=&#123;0.5 rows, 0.505 cpu, 0.0 io&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/09/Calcite-Volcano-Planner/image-20200131224924660.png" alt="image-20200131224924660"></p>
<h3 id="buildCheapestPlan"><a href="#buildCheapestPlan" class="headerlink" title="buildCheapestPlan"></a>buildCheapestPlan</h3><p>从 root 开始一路选subset 中的 best, 就得到了一颗最优的树:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumerableInterpreter</span><br><span class="line">  BindableTableScan(<span class="keyword">table</span><span class="operator">=</span>[[SALES, EMPS]], filters<span class="operator">=</span>[[<span class="operator">=</span>($<span class="number">1</span>, <span class="string">&#x27;John&#x27;</span>)]])</span><br></pre></td></tr></table></figure>

<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><ol>
<li>第一次找到可执行计划的计划(cost 不为 inf), 其对应的 Cost 暂时记为 BestCost</li>
<li>制定下一次优化要达到的目标为 BestCost*0.9，再根据当前的迭代次数计算 giveUpTick，这个值代表的意思是：如果迭代次数超过这个值还没有达到优化目标，那么将会放弃迭代</li>
<li>如果 RuleQueue 中 RuleMatch 为空，那么也会退出迭代</li>
<li>在每次迭代时都会从 RuleQueue 中选择一个 RuleMatch，策略是选择一个最高 importance 的 RuleMatch</li>
<li>最后根据 best plan，构建其对应的 RelNode</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ol>
<li>为异构数据源提供了原生支持 (conversion 机制)</li>
<li>volcano 的优化规则顺序不需要人工保证, 因为每次新生成一个节点, 会去执行 fireRule, 找到所有这个节点感兴趣的 rule 放到 RuleQueue 中, 当同时带来缺点 1.</li>
</ol>
<p>缺点:</p>
<ol>
<li>CBO 是个伪命题, 执行的框架模型很不错, 但是如何准确预估 cost 是难点(Filter/Join/Agg)</li>
<li>更好的方式是做成 runtime 的, 一边执行, 一边根据执行的 stats 调整查询计划的形式(ae/runtime filter).</li>
<li>重复应用规则, 有一些(很多)规则会同时被 logical/physical nodes 触发, 比如 ProjectRemoveRule 接受 Project.class, 而 Project 是逻辑/物理 Project 的 基类, 很多规则仅在逻辑执行计划上 apply 就可以了. 在社区的讨论中, 去掉了这种 case, planning 的时间提升 30% (CALCITE-2970);</li>
<li>Calcite 的 Volcano Planner 没有任何剪枝, 举例来说, 当计算一个计划到某个节点的 cost 已经比之前的 best 都高了, 则可以剪去这一枝;</li>
<li>本质上还是一个单机的优化引擎, 没有考虑分布式的优化(对比 Spark , Calcite 可以理解为无物理优化)<ol>
<li>默认优化流程里根本没有加入 RelDistribution 的考虑, 也没有提供配置</li>
<li>Distribution 也不是分布式的, 举例 calcite 的 HASH_DISTRIBUTED 值考虑了 Key, hash 的 func/num 都没有记录</li>
<li>Aggregate 只有一种, 对比 Spark 有多种策略(planAggregateWithoutDistinct/planAggregateWithOneDistinct/planStreamingAggregation)</li>
<li>有多种 join, 但是 join 策略比较弱, 没有考虑数据量(对比 Spark 的 JoinSelection), 也不支持 hint</li>
</ol>
</li>
<li>引入 AbstractConverter 来做 Spark ensureRequirement 类似的事情, 但是做的方式比较别扭, AbstractConverter 是一个执行计划中的节点, 会触发一个特定的规则 ExpandConversionRule 来保证 Distribution/Sort/Convertion, 邮件列表中讨论到这种方式污染了规则的 search space(polluting the search space), 导致了3-9 倍不必要的规则触发(对比 spark 是递归处理 root-child, calcite 每次只处理父子两个节点, 不递归). 由于它潜在的性能问题(CALCITE-2970 ), AbstractConverter 在 Calcite 代码中是默认关闭的, 详见社区讨论: Volcano’s problem with trait propagation: current state and future;</li>
<li>复杂度高, 不利于调试问题.</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.id <span class="keyword">AS</span> user_id,</span><br><span class="line">    u.name <span class="keyword">AS</span> user_name,</span><br><span class="line">    j.company <span class="keyword">AS</span> user_company,</span><br><span class="line">    u.age <span class="keyword">AS</span> user_age</span><br><span class="line"><span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> u.id<span class="operator">=</span>j.id</span><br><span class="line"><span class="keyword">WHERE</span> u.age <span class="operator">&gt;</span> <span class="number">30</span></span><br><span class="line"> <span class="keyword">AND</span> j.id<span class="operator">&gt;</span><span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id&quot;</span><br></pre></td></tr></table></figure>

<p>共形成了 31 个 group(relset), 1000 个节点(开启了3 种 RelTraitDef)</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>[1]. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58801070">https://zhuanlan.zhihu.com/p/58801070</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60223655">https://zhuanlan.zhihu.com/p/60223655</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/BigData/" rel="tag"><i class="fa fa-tag"></i> BigData</a>
              <a href="/tags/Calcite/" rel="tag"><i class="fa fa-tag"></i> Calcite</a>
              <a href="/tags/OLAP/" rel="tag"><i class="fa fa-tag"></i> OLAP</a>
              <a href="/tags/Optimizer/" rel="tag"><i class="fa fa-tag"></i> Optimizer</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/08/Calcite%20-%20Parser%20%E9%83%A8%E5%88%86/" rel="prev" title="Calcite - Parser 部分">
      <i class="fa fa-chevron-left"></i> Calcite - Parser 部分
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/25/Calcite-Not-in-opt/" rel="next" title="Calcite Not in 转 cross join">
      Calcite Not in 转 cross join <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">优化器模型介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cascade-Volcano"><span class="nav-number">1.1.</span> <span class="nav-text">Cascade&#x2F;Volcano</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Init-Memo"><span class="nav-number">1.1.1.</span> <span class="nav-text">Init Memo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Apply-transformation-implement-rule"><span class="nav-number">1.1.2.</span> <span class="nav-text">Apply transformation&#x2F;implement rule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-best-plan"><span class="nav-number">1.1.3.</span> <span class="nav-text">Find best plan</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Calcite-Volcano-Planner"><span class="nav-number">2.</span> <span class="nav-text">Calcite Volcano Planner</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">基本流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="nav-number">2.2.1.</span> <span class="nav-text">入口点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-default-rule-trait"><span class="nav-number">2.2.2.</span> <span class="nav-text">set default rule&#x2F;trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setRoot-1st"><span class="nav-number">2.2.3.</span> <span class="nav-text">setRoot (1st)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setRoot-2st"><span class="nav-number">2.2.4.</span> <span class="nav-text">setRoot (2st)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#findBestExp"><span class="nav-number">2.3.</span> <span class="nav-text">findBestExp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setInitialImportance"><span class="nav-number">2.3.1.</span> <span class="nav-text">setInitialImportance()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RuleQueue-popMatch"><span class="nav-number">2.3.2.</span> <span class="nav-text">RuleQueue#popMatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buildCheapestPlan"><span class="nav-number">2.3.3.</span> <span class="nav-text">buildCheapestPlan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref"><span class="nav-number">2.4.</span> <span class="nav-text">Ref</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiatao Tao"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">Jiatao Tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aaaaaaron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aaaaaaron" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tao@apache.org" title="E-Mail → mailto:tao@apache.org" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiatao Tao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a>
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://aron.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/",
            identifier: "2020/02/09/Calcite-Volcano-Planner/",
            title: "Calcite Volcano Planner"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://aron.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
