<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;0-启动开销&quot;&gt;&lt;a href=&quot;#0-启动开销&quot; class=&quot;headerlink&quot; title=&quot;0. 启动开销&quot;&gt;&lt;/a&gt;0. 启动开销&lt;/h3&gt;&lt;p&gt;总结: Spark 计算比 MapReduce 快的根本原因在于DAG计算模型, 但 MR 真正的缺点是抽象层次太低, 大量底层逻辑需要开发者手工完成. 但是也不是说 MR 就已经没用了, 没有最好的技术, 只有合适你需求的技术."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Hadoop MR 和 Spark 对比 | Jiatao Tao's blog</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-time">2018-11-02</div></div></div><div class="container post-header"><h1>Hadoop MR 和 Spark 对比</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-启动开销"><span class="toc-number">1.</span> <span class="toc-text">0. 启动开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-启动开销"><span class="toc-number">2.</span> <span class="toc-text">1. 启动开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DAG-优化"><span class="toc-number">3.</span> <span class="toc-text">2. DAG 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消除了冗余的-HDFS-读写"><span class="toc-number">3.1.</span> <span class="toc-text">消除了冗余的 HDFS 读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消除了冗余的-MapReduce-阶段"><span class="toc-number">3.2.</span> <span class="toc-text">消除了冗余的 MapReduce 阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cache"><span class="toc-number">4.</span> <span class="toc-text">3. Cache</span></a></li></ol></details></div><div class="container post-content"><h3 id="0-启动开销"><a href="#0-启动开销" class="headerlink" title="0. 启动开销"></a>0. 启动开销</h3><p>总结: Spark 计算比 MapReduce 快的根本原因在于DAG计算模型, 但 MR 真正的缺点是抽象层次太低, 大量底层逻辑需要开发者手工完成. 但是也不是说 MR 就已经没用了, 没有最好的技术, 只有合适你需求的技术.</p>
<h3 id="1-启动开销"><a href="#1-启动开销" class="headerlink" title="1. 启动开销"></a>1. 启动开销</h3><p>Hadoop MapReduce 采用了多进程模型, 而Spark采用了多线程模型. </p>
<p>Hadoop MapReduce 每个 Mpa task/Reduce Task 都是一个 JVM, 是基于进程的, task 的启动时间在秒级, 然后用完后又立即释放, 不能被其他任务重用; Spark executor 是常驻的, taks 是基于线程的, 而且由于在一个 JVM 中, 方便数据共享.</p>
<p>但是基于进程的好处是每个 task 都可以控制自己的资源粒度, 而线程的资源隔离并没有保证.</p>
<p> MR 稳定是真的. 现在越来越觉得稳定性比性能重要很多, MR 虽然慢, 但是基本上能保证跑出结果. MR 真正的缺点是MR抽象层次太低, 大量底层逻辑需要开发者手工完成.</p>
<h3 id="2-DAG-优化"><a href="#2-DAG-优化" class="headerlink" title="2. DAG 优化"></a>2. DAG 优化</h3><h4 id="消除了冗余的-HDFS-读写"><a href="#消除了冗余的-HDFS-读写" class="headerlink" title="消除了冗余的 HDFS 读写"></a>消除了冗余的 HDFS 读写</h4><p>单个 MR job 和 Spark 其实可能也没啥区别, 差异主要在多个MR组成的复杂Job来和Spark比</p>
<p>对于一个 job, 会启动很多轮 MR 组合计算, MR 每次都会从 HDFS 读, 再写回到 HDFS, 下轮 MR 任务又要从 HDFS 读, 但是 Spark 只需要一个 job, 只读写 HDFS 一次. 中间只落本地磁盘.</p>
<h4 id="消除了冗余的-MapReduce-阶段"><a href="#消除了冗余的-MapReduce-阶段" class="headerlink" title="消除了冗余的 MapReduce 阶段"></a>消除了冗余的 MapReduce 阶段</h4><p>Spark lazy evaluation, 减少不必要的 stage, 可以减少 shuffle 次数, 要是没有 shuffle, Spark可以在内存中一次性完成这些操作.</p>
<h3 id="3-Cache"><a href="#3-Cache" class="headerlink" title="3. Cache"></a>3. Cache</h3><p>Spark 可以指定 Cache 某个 RDD, 以加速后面计算.</p>
<p>TBD: 从更高维度剖析 Hadoop MR 和 SQL 系统的区别.</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>