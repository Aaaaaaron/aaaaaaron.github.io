<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="oi9cACXaYdEyQVeGEUG_WUOEeFyJe9ey2Sj7Dcribng">
  <meta name="baidu-site-verification" content="code-W1bppEiaZ5">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://aaaaaaron.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: false,
    comments: {"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="概览所用代码为 2022.10.15 ClickHouse master 分支: 9ccbadc359d05fad8a1f3d80d6677b55b3006c2c 概念Block：数据块，ClickHouse进行数据读、写的基本单元，每一个Block实例，不仅包含数据域，还包含了每个列的meta信息。 Chunk：数据块，保存实际数据的单元，Block中的数据域的指向的就是这个类型的实例。 Row">
<meta property="og:type" content="article">
<meta property="og:title" content="Clickhouse pipeline&#x2F;processor 源码解析 101">
<meta property="og:url" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/index.html">
<meta property="og:site_name" content="Jiatao Tao&#39;s blog">
<meta property="og:description" content="概览所用代码为 2022.10.15 ClickHouse master 分支: 9ccbadc359d05fad8a1f3d80d6677b55b3006c2c 概念Block：数据块，ClickHouse进行数据读、写的基本单元，每一个Block实例，不仅包含数据域，还包含了每个列的meta信息。 Chunk：数据块，保存实际数据的单元，Block中的数据域的指向的就是这个类型的实例。 Row">
<meta property="og:locale">
<meta property="og:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDU0OTk=,size_16,color_FFFFFF,t_70-20221015185919620.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/image-20221015190825669.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/image-20221015195335512.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/image-20221015195701706.png">
<meta property="og:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/image-20221016182708361.png">
<meta property="article:published_time" content="2022-10-15T10:37:35.000Z">
<meta property="article:modified_time" content="2022-10-16T13:51:44.163Z">
<meta property="article:author" content="Jiatao Tao">
<meta property="article:tag" content="clickhouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDU0OTk=,size_16,color_FFFFFF,t_70-20221015185919620.png">

<link rel="canonical" href="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Clickhouse pipeline/processor 源码解析 101 | Jiatao Tao's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jiatao Tao's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">λ</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-desktop"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://aaaaaaron.github.io/2022/10/15/clickhouse-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Jiatao Tao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiatao Tao's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Clickhouse pipeline/processor 源码解析 101
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-15 18:37:35" itemprop="dateCreated datePublished" datetime="2022-10-15T18:37:35+08:00">2022-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-16 21:51:44" itemprop="dateModified" datetime="2022-10-16T21:51:44+08:00">2022-10-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>所用代码为 2022.10.15 ClickHouse master 分支: 9ccbadc359d05fad8a1f3d80d6677b55b3006c2c</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Block：数据块，ClickHouse进行数据读、写的基本单元，每一个Block实例，不仅包含数据域，还包含了每个列的meta信息。</p>
<p>Chunk：数据块，保存实际数据的单元，Block中的数据域的指向的就是这个类型的实例。</p>
<p>Row：一行记录，包含多个列索引，Chunk可以认为是由多个Row组成的。</p>
<p>Column：一列数据，包含一个列上的Block Size数量的行。</p>
<p>一个Block对象，可以简单理解为一张表，它的每一列都有相同的长度，每一行长度也等.</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 以TCP连接为例 select id from query_cache;</span><br><span class="line">TCPHandler::runImpl</span><br><span class="line">    BlockIO executeQuery // 解析query</span><br><span class="line">        executeQueryImpl</span><br><span class="line">            ast = parseQuery // 解析生成ast</span><br><span class="line">                ...</span><br><span class="line">            interpreter = InterpreterFactory::get // 根据ast实例化interpreter</span><br><span class="line">            interpreter-&gt;execute() // InterpreterSelectWithUnionQuery::execute</span><br><span class="line">                buildQueryPlan // 构建query paln 如 InterpreterSelectQuery::buildQueryPlan</span><br><span class="line">                    InterpreterSelectQuery::executeImpl</span><br><span class="line">                        executeFetchColumns</span><br><span class="line">                            storage-&gt;read // StorageMergeTree::read --&gt; MergeTreeDataSelectExecutor::read</span><br><span class="line">                                StorageMergeTree::read</span><br><span class="line">                                    MergeTreeDataSelectExecutor::read</span><br><span class="line">                                        MergeTreeDataSelectExecutor::readFromParts // 根据一定条件选择需要读取的part，这里我们过滤掉如何选择的流程，直接去看怎么构建query plan</span><br><span class="line">                                            spreadMarkRangesAmongStreams // 构建queryplan</span><br><span class="line">                                                MergeTreeThreadSelectBlockInputProcessor</span><br><span class="line">                                                unitePipes // 多个pipe绑定为一个pipe</span><br><span class="line">                                                createPlanFromPipe // step = std::make_unique&lt;ReadFromStorageStep&gt;; plan-&gt;addStep(step); processor为MergeTreeThreadSelectBlockInputProcessor</span><br><span class="line">                            query_plan.addStep // 增加step SettingQuotaAndLimits</span><br><span class="line">                        executeExpression // 增加step ExpressionStep</span><br><span class="line">                        executeProjection // 增加step ExpressionStep</span><br><span class="line">                buildQueryPipeline // 构建pipeline</span><br><span class="line">                    updatePipeline // ITransformingStep::updatePipeline--&gt;ExpressionStep::transformPipeline--&gt;addSimpleTransform--&gt;collected_processors指向的processors和pipe.processors都增加processor; 即ExpressionTransform</span><br><span class="line">            pipeline.addSimpleTransform // 增加processor LimitsCheckingTransform</span><br><span class="line">    processOrdinaryQueryWithProcessors</span><br><span class="line">        sendData(header); // 先向client发送header</span><br><span class="line">        PullingAsyncPipelineExecutor executor(pipeline); // 构建一个执行器。 make_shared&lt;LazyOutputFormat&gt;</span><br><span class="line">        PullingAsyncPipelineExecutor::pull</span><br><span class="line">            threadFunction</span><br><span class="line">                PipelineExecutor::execute</span><br><span class="line">                    PipelineExecutor::executeImpl</span><br><span class="line">                        initializeExecution</span><br><span class="line">                            prepareProcessor</span><br><span class="line">                                processor-&gt;prepare // 执行pushdata和pulldata操作</span><br><span class="line">                        executeSingleThread</span><br><span class="line">                            executeStepImpl // 根据线程号，弹出任务</span><br><span class="line">                                addJob // 初始化node-&gt;job</span><br><span class="line">                                node-&gt;job()</span><br><span class="line">                                    executeJob</span><br><span class="line">                                        processor-&gt;work() // 各个processor执行</span><br><span class="line">                                            ...</span><br><span class="line">    state.io.onFinish() // log和状态记录</span><br></pre></td></tr></table></figure>



<p><img src="/2022/10/15/clickhouse-pipeline/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDU0OTk=,size_16,color_FFFFFF,t_70-20221015185919620.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/15/clickhouse-pipeline/image-20221015190825669.png" alt="image-20221015190825669"></p>
<h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><p>由于之前一直做优化器相关的 SQL 层, 各个引擎都是大同小异, 所以这里对 SQL 层不会特别深入, CH 的 SQL 层目前也不太完善, 没有太多可介绍的</p>
<h2 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interpreter = InterpreterFactory::<span class="built_in">get</span>(ast, context, <span class="built_in">SelectQueryOptions</span>(stage).<span class="built_in">setInternal</span>(internal));</span><br></pre></td></tr></table></figure>

<p>在老版本的 CH 中(ch19), interpreter 直接构造了输入输出流(input stream/ output stream), 通过这些 stream 串起了整个查询</p>
<p>对于不同的查询类型(DQL/DML/DDL) 等有不同的 interpreter, 我们这里主要关注和 DQL 相关的``InterpreterSelectQuery`</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockIO <span class="title">InterpreterSelectQuery::execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockIO res;</span><br><span class="line">    QueryPlan query_plan;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buildQueryPlan</span>(query_plan);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">auto</span> builder = query_plan.<span class="built_in">buildQueryPipeline</span>(</span><br><span class="line">        QueryPlanOptimizationSettings::<span class="built_in">fromContext</span>(context), </span><br><span class="line">        BuildQueryPipelineSettings::<span class="built_in">fromContext</span>(context));</span><br><span class="line">  </span><br><span class="line">    res.pipeline = QueryPipelineBuilder::<span class="built_in">getPipeline</span>(std::<span class="built_in">move</span>(*builder));</span><br><span class="line">    <span class="built_in">setQuota</span>(res.pipeline);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="buildQueryPlan"><a href="#buildQueryPlan" class="headerlink" title="buildQueryPlan"></a>buildQueryPlan</h3><p>构建逻辑执行计划</p>
<p>QueryPlan 实际上是一棵<code>QueryPlanStep</code>树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueryPlanStepPtr step;</span><br><span class="line">    std::vector&lt;Node *&gt; children = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Nodes = std::list&lt;Node&gt;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryPlan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Nodes nodes;</span><br><span class="line">    Node * root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IQueryPlanStep"><a href="#IQueryPlanStep" class="headerlink" title="IQueryPlanStep"></a>IQueryPlanStep</h4><p>这是一个基类, 每个 sql 算子都会又对应的实现</p>
<p>直接继承 IQueryPlanStep 的, 一般都继承 ITransformingStep/ISourceStep, 比较复杂的 case 会直接继承 IQueryPlanStep, 例如 JoinStep, 需要自己实现 <code>QueryPipelineBuilderPtr updatePipeline</code> , 比较复杂</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ISourceStep</span><br><span class="line">CreatingSetsStep</span><br><span class="line">ITransformingStep</span><br><span class="line">IntersectOrExceptStep</span><br><span class="line">JoinStep</span><br><span class="line">UnionStep</span><br></pre></td></tr></table></figure>

<h5 id="举例-UnionStep"><a href="#举例-UnionStep" class="headerlink" title="举例: UnionStep"></a>举例: UnionStep</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueryPipelineBuilderPtr <span class="title">UnionStep::updatePipeline</span><span class="params">(QueryPipelineBuilders pipelines, <span class="keyword">const</span> BuildQueryPipelineSettings &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pipeline = std::make_unique&lt;QueryPipelineBuilder&gt;();</span><br><span class="line">    <span class="function">QueryPipelineProcessorsCollector <span class="title">collector</span><span class="params">(*pipeline, <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipelines.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pipeline-&gt;<span class="built_in">init</span>(<span class="built_in">Pipe</span>(std::make_shared&lt;NullSource&gt;(output_stream-&gt;header)));</span><br><span class="line">        processors = collector.<span class="built_in">detachProcessors</span>();</span><br><span class="line">        <span class="keyword">return</span> pipeline;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; cur_pipeline : pipelines)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// Headers for union must be equal.</span></span><br><span class="line">        <span class="comment">/// But, just in case, convert it to the same header if not.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isCompatibleHeader</span>(cur_pipeline-&gt;<span class="built_in">getHeader</span>(), <span class="built_in">getOutputStream</span>().header))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> converting_dag = ActionsDAG::<span class="built_in">makeConvertingActions</span>(</span><br><span class="line">                cur_pipeline-&gt;<span class="built_in">getHeader</span>().<span class="built_in">getColumnsWithTypeAndName</span>(),</span><br><span class="line">                <span class="built_in">getOutputStream</span>().header.<span class="built_in">getColumnsWithTypeAndName</span>(),</span><br><span class="line">                ActionsDAG::MatchColumnsMode::Name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> converting_actions = std::make_shared&lt;ExpressionActions&gt;(std::<span class="built_in">move</span>(converting_dag));</span><br><span class="line">            cur_pipeline-&gt;<span class="built_in">addSimpleTransform</span>([&amp;](<span class="keyword">const</span> Block &amp; cur_header)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> std::make_shared&lt;ExpressionTransform&gt;(cur_header, converting_actions);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pipeline = QueryPipelineBuilder::<span class="built_in">unitePipelines</span>(std::<span class="built_in">move</span>(pipelines), max_threads);</span><br><span class="line"></span><br><span class="line">    processors = collector.<span class="built_in">detachProcessors</span>();</span><br><span class="line">    <span class="keyword">return</span> pipeline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ITransformingStep"><a href="#ITransformingStep" class="headerlink" title="ITransformingStep"></a>ITransformingStep</h4><p>最重要的是 ITransformingStep, 几乎所有算子都继承自 ITransformingStep, 例如 filter/sort/limit 等等</p>
<p>ITransformingStep 有单个的输入/输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExpressionStep</span><br><span class="line">AggregatingStep</span><br><span class="line">ArrayJoinStep</span><br><span class="line">CreateSetAndFilterOnTheFlyStep</span><br><span class="line">CreatingSetStep</span><br><span class="line">CubeStep</span><br><span class="line">DistinctStep</span><br><span class="line">ExtremesStep</span><br><span class="line">FillingStep</span><br><span class="line">FilterStep</span><br><span class="line">FilledJoinStep</span><br><span class="line">LimitByStep</span><br><span class="line">LimitStep</span><br><span class="line">Merging AggregatedStep</span><br><span class="line">OffsetStep</span><br><span class="line">RollupStep</span><br><span class="line">SortingStep</span><br><span class="line">TotalsHaving Step</span><br><span class="line">WindowStep</span><br></pre></td></tr></table></figure>

<h5 id="举例-FilterStep"><a href="#举例-FilterStep" class="headerlink" title="举例: FilterStep"></a>举例: FilterStep</h5><p>step 中会定义 <code>transformPipeline</code>, <code>xxxTransFORM</code> 就是物理执行的算子(processer), 这个后面 在 query pipeline 中会介绍到, 等于是从逻辑执行计划到物理执行计划的一个转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterStep::transformPipeline</span><span class="params">(QueryPipelineBuilder &amp; pipeline, <span class="keyword">const</span> BuildQueryPipelineSettings &amp; settings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> expression = std::make_shared&lt;ExpressionActions&gt;(actions_dag, settings.<span class="built_in">getActionsSettings</span>());</span><br><span class="line">    pipeline.<span class="built_in">addSimpleTransform</span>([&amp;](<span class="keyword">const</span> Block &amp; header, QueryPipelineBuilder::StreamType stream_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> on_totals = stream_type == QueryPipelineBuilder::StreamType::Totals;</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;FilterTransform&gt;(header, expression, filter_column_name, remove_filter_column, on_totals);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ISourceStep"><a href="#ISourceStep" class="headerlink" title="ISourceStep"></a>ISourceStep</h4><p>Step which takes empty pipeline and initializes it. Returns single logical DataStream.</p>
<p>子类需要实现 <code>initializePipeline</code>, 主要就是要构造 <code>Pipe</code></p>
<img src="/2022/10/15/clickhouse-pipeline/image-20221015195335512.png" alt="image-20221015195335512" style="zoom:50%;">

<h5 id="举例-ReadFromRemote"><a href="#举例-ReadFromRemote" class="headerlink" title="举例: ReadFromRemote"></a>举例: ReadFromRemote</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFromRemote::initializePipeline</span><span class="params">(QueryPipelineBuilder &amp; pipeline, <span class="keyword">const</span> BuildQueryPipelineSettings &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pipes pipes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; shard : shards)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shard.lazy)</span><br><span class="line">            <span class="built_in">addLazyPipe</span>(pipes, shard);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">addPipe</span>(pipes, shard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pipe = Pipe::<span class="built_in">unitePipes</span>(std::<span class="built_in">move</span>(pipes));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; processor : pipe.<span class="built_in">getProcessors</span>())</span><br><span class="line">        processor-&gt;<span class="built_in">setStorageLimits</span>(storage_limits);</span><br><span class="line"></span><br><span class="line">    pipeline.<span class="built_in">init</span>(std::<span class="built_in">move</span>(pipe));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="buildQueryPlan-执行流程"><a href="#buildQueryPlan-执行流程" class="headerlink" title="buildQueryPlan 执行流程"></a>buildQueryPlan 执行流程</h4><img src="/2022/10/15/clickhouse-pipeline/image-20221015195701706.png" alt="image-20221015195701706" style="zoom:50%;">

<p>主要执行流程在 <code>void InterpreterSelectQuery::executeImpl(QueryPlan &amp; query_plan, std::optional&lt;Pipe&gt; prepared_pipe)</code>中, 代码很长</p>
<p>主体流程就是根据 query 来给 QueryPlan 添加 step, 这里不想过多篇幅花在sql 层, 具体大家可以自己看</p>
<p>例如 InterpreterSelectQuery::executeWhere</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterpreterSelectQuery::executeWhere</span><span class="params">(QueryPlan &amp; query_plan, <span class="keyword">const</span> ActionsDAGPtr &amp; expression, <span class="keyword">bool</span> remove_filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> where_step = std::make_unique&lt;FilterStep&gt;(</span><br><span class="line">        query_plan.<span class="built_in">getCurrentDataStream</span>(), expression, <span class="built_in">getSelectQuery</span>().<span class="built_in">where</span>()-&gt;<span class="built_in">getColumnName</span>(), remove_filter);</span><br><span class="line"></span><br><span class="line">    where_step-&gt;<span class="built_in">setStepDescription</span>(<span class="string">&quot;WHERE&quot;</span>);</span><br><span class="line">    query_plan.<span class="built_in">addStep</span>(std::<span class="built_in">move</span>(where_step));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>InterpreterSelectQuery 中的其他 execute 方法, 都会在 <code>InterpreterSelectQuery::executeImpl</code> 调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">executeMergeAggregatedImpl</span><br><span class="line">executeAggregation</span><br><span class="line">executeDistinct</span><br><span class="line">executeExpression</span><br><span class="line">executeExtremes</span><br><span class="line">executeFetchColumns</span><br><span class="line">executeHaving</span><br><span class="line">executeLimit</span><br><span class="line">executeLimitBy</span><br><span class="line">executeMergeAggregated</span><br><span class="line">executeMergeSorted</span><br><span class="line">executeOffset</span><br><span class="line">executeOrder</span><br><span class="line">executeOrderOptimized</span><br><span class="line">executePreLimit</span><br><span class="line">executeProjection</span><br><span class="line">executeRollupOrCube</span><br><span class="line">executeSubqueriesInSetsAndJoins</span><br><span class="line">executeTotalsAndHaving</span><br><span class="line">executeWhere</span><br><span class="line">executeWindow</span><br><span class="line">executeWithFill</span><br></pre></td></tr></table></figure>

<p>最后我们生成了一颗 QueryPlanStep 的树, 完成了 ast 到逻辑执行计划的转换</p>
<h3 id="buildQueryPipeline"><a href="#buildQueryPipeline" class="headerlink" title="buildQueryPipeline"></a>buildQueryPipeline</h3><p><code>buildQueryPipeline()</code>方法会将逻辑树中的一个个<code>QueryPlanStep</code>结点, 自底向上, 从左向右转换成<code>IProcessor</code>的实例对象, 也就是物理计划树中的结点, 将组织成QueryPipeline的结构</p>
<h4 id="IProcessor"><a href="#IProcessor" class="headerlink" title="IProcessor"></a>IProcessor</h4><p>基类, 名字一般叫 xxTransform, xxProcessor, 主要关注 ISimpleTransform/ISink/ISource</p>
<ul>
<li>有零个或多个输入端口和零个或多个输出端口</li>
<li>Block 通过 port 传输</li>
<li>每个 port 都有固定的结构：列的名称和类型以及常量的值</li>
<li>Processors 需要从 input ports pull data, 做一些处理然后 push data 到 output ports</li>
<li><strong>Processors同步的处理不要有任何的休眠/io, 只能纯 cpu 的</strong></li>
<li>上面的操作, Processors 更希望是通过异步的操作<ul>
<li>可以启动后台任务并且订阅</li>
</ul>
</li>
<li>Processor may modify its ports (create another processors and connect to them) on the fly<ul>
<li>例如首先执行子查询, 根据子查询的结果, 决定如何执行查询的其余部分并构建相应的管道</li>
</ul>
</li>
<li>source: 没有 input, 1 个 output, <strong>自己生成数据</strong>然后 push 到它的 output port<ul>
<li>Empty source: Immediately says that data on its output port is finished.</li>
</ul>
</li>
<li>sink: 1个 input, 0 个 output, 消费上游的数据<ul>
<li>Null sink. Consumes data and does nothing.</li>
</ul>
</li>
<li>Simple transformation: single input/output port<ul>
<li>最好让每个函数成为一个单独的 processor, 更适合 processor 的分析</li>
</ul>
</li>
<li>Squashing or filtering transformation: 提取数据, 可能会累积数据, 有时会将其推送到 output port<ul>
<li>e.g. DISTINCT, WHERE, squashing of blocks for INSERT SELECT.</li>
</ul>
</li>
<li>Accumulating transformation: 从输入中提取并累积所有数据，直到耗尽, 然后将数据推送到 output port<ul>
<li>e.g. ORDER BY, GROUP BY</li>
</ul>
</li>
<li>Limiting transformation. 当数据足够时, input port 不再需要数据</li>
<li>Resize: 具有任意数量的输入和任意数量的输出<ul>
<li>从任何准备好的输入中提取数据并将其推送到随机选择的自由输出, 例子: Union</li>
</ul>
</li>
<li>Split: 从一个输入读取数据并将其传递到任意输出</li>
<li>Concat: 有很多输入，只有一个输出。从第一个输入中提取所有数据，直到用完, 然后来自第二个输入的所有数据等，并将所有数据推送到输出。</li>
<li>Ordered merge: Has many inputs but only one output. Pulls data from selected input in specific order, merges and pushes it to output</li>
<li>Fork: 具有一个输入和多个输出。从输入中提取数据并将其复制到所有输出<ul>
<li>用于处理具有共同数据源的多个查询</li>
</ul>
</li>
<li>Select: 具有一个或多个输入和一个输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProcessor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    InputPorts inputs;</span><br><span class="line">    OutputPorts outputs;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IProcessor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IProcessor</span>(InputPorts inputs_, OutputPorts outputs_)</span><br><span class="line">        : <span class="built_in">inputs</span>(std::<span class="built_in">move</span>(inputs_)), <span class="built_in">outputs</span>(std::<span class="built_in">move</span>(outputs_))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; port : inputs)</span><br><span class="line">            port.processor = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; port : outputs)</span><br><span class="line">            port.processor = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method &#x27;prepare&#x27; is responsible for all cheap (&quot;instantaneous&quot;: O(1) of data volume, no wait) calculations.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * It may access input and output ports,</span></span><br><span class="line"><span class="comment">      *  indicate the need for work by another processor by returning NeedData or PortFull,</span></span><br><span class="line"><span class="comment">      *  or indicate the absence of work by returning Finished or Unneeded,</span></span><br><span class="line"><span class="comment">      *  it may pull data from input ports and push data to output ports.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * The method is not thread-safe and must be called from a single thread in one moment of time,</span></span><br><span class="line"><span class="comment">      *  even for different connected processors.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * Instead of all long work (CPU calculations or waiting) it should just prepare all required data and return Ready or Async.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * Thread safety and parallel execution:</span></span><br><span class="line"><span class="comment">      * - no methods (prepare, work, schedule) of single object can be executed in parallel;</span></span><br><span class="line"><span class="comment">      * - method &#x27;work&#x27; can be executed in parallel for different objects, even for connected processors;</span></span><br><span class="line"><span class="comment">      * - method &#x27;prepare&#x27; cannot be executed in parallel even for different objects,</span></span><br><span class="line"><span class="comment">      *   if they are connected (including indirectly) to each other by their ports;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/** You may call this method if &#x27;prepare&#x27; returned Ready.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * This method cannot access any ports. It should use only data that was prepared by &#x27;prepare&#x27; method.</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * Method work can be executed in parallel for different processors.</span></span></span><br><span class="line"><span class="comment"><span class="function">      */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/** Executor must call this method when &#x27;prepare&#x27; returned Async.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * This method cannot access any ports. It should use only data that was prepared by &#x27;prepare&#x27; method.</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * This method should instantly return epollable file descriptor which will be readable when asynchronous job is done.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * When descriptor is readable, method `work` is called to continue data processing.</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * <span class="doctag">NOTE:</span> it would be more logical to let `work()` return ASYNC status instead of prepare. This will get</span></span></span><br><span class="line"><span class="comment"><span class="function">      * prepare() -&gt; work() -&gt; schedule() -&gt; work() -&gt; schedule() -&gt; .. -&gt; work() -&gt; prepare()</span></span></span><br><span class="line"><span class="comment"><span class="function">      * chain instead of</span></span></span><br><span class="line"><span class="comment"><span class="function">      * prepare() -&gt; work() -&gt; prepare() -&gt; schedule() -&gt; work() -&gt; prepare() -&gt; schedule() -&gt; .. -&gt; work() -&gt; prepare()</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * It is expected that executor epoll using level-triggered notifications.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * Read all available data from descriptor before returning ASYNC.</span></span></span><br><span class="line"><span class="comment"><span class="function">      */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/** You must call this method if &#x27;prepare&#x27; returned ExpandPipeline.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * This method cannot access any port, but it can create new ports for current processor.</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * Method should return set of new already connected processors.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * All added processors must be connected only to each other or current processor.</span></span></span><br><span class="line"><span class="comment"><span class="function">      *</span></span></span><br><span class="line"><span class="comment"><span class="function">      * Method can&#x27;t remove or reconnect existing ports, move data from/to port or perform calculations.</span></span></span><br><span class="line"><span class="comment"><span class="function">      * &#x27;prepare&#x27; should be called again after expanding pipeline.</span></span></span><br><span class="line"><span class="comment"><span class="function">      */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> Processors <span class="title">expandPipeline</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        is_cancelled = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">onCancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    IQueryPlanStep * query_plan_step = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Processor-状态"><a href="#Processor-状态" class="headerlink" title="Processor 状态"></a>Processor 状态</h5><ul>
<li>NeedData: Processor 需要 input 提供数据, 需要运行另一个 processor 来生成所需的 input, 然后调用 prepare 方法</li>
<li>PortFull: Processor 由于端口满或者不需要主数据(inNeeded()) 从而不能处理数据, 你需要把数据从 output 端口 transfer 到另一个 processor 的 input 端口然后调用 prepare 方法</li>
<li>Finished: 所有工作完成 (all data is processed or all output are closed)</li>
<li>Unneeded: No one needs data on output ports.</li>
<li>Ready: 你可以调用 “work” 方法, processor 会同步的处理数据</li>
<li>Async: 你可以调用 “schedule” 方法, processor 会返回一个 descriptor, 你需要 poll(轮询) 这个 descriptor 并且调用 work 方法</li>
<li>ExpandPipeline: Processor 想添加其他 Processor 到这个 pipeline 中, 新的 processors 必须通过 expandPipeline() 调用获得</li>
</ul>
<h5 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h5><p>重点: prepare, work, schedule 单个对象上都不能并行执行, 但是 work 在不同 processor 上可以并行执行</p>
<ol>
<li><code>Status prepare()</code>: <ol>
<li>负责所有 cheap 的计算(O1, 无等待)</li>
<li>可能访问input/output ports, 通过返回 NeedData 或 PortFull 表示需要另一个Processor工作, 或通过返回 Finished 或 Unneeded 来表示不需要工作</li>
<li>它可以从输入端口提取数据并将数据推送到输出端口</li>
<li>该方法不是线程安全的, 即使对于不同的实例, 也不能并行执行, 如果他们通过端口互相 connect (including indirectly)</li>
<li>它应该只准备所有需要的数据并返回 Ready 或 Async, 而不是长时间的工作(cpu计算或者 io 等待)</li>
</ol>
</li>
<li><code>void work()</code><ol>
<li>prepare 返回 ready 需要调用</li>
<li>可以在不同 processor 间并行执行 </li>
</ol>
</li>
<li><code>int schedule()</code><ol>
<li>prepare 返回 Async 需要调用</li>
<li>方法不能访问任何 ports, 他只能使用 prepare() 准备的数据</li>
<li>此方法应立即返回 epollable 文件描述符, 该描述符在异步作业完成时可读, 描述符可读时, 调用方法<code>work</code>继续数据处理</li>
<li>让 <code>work()</code> 返回 ASYNC 状态而不是 prepare 会更合乎逻辑:  prepare() -&gt; work() -&gt; schedule() -&gt; work() -&gt; schedule() -&gt; .. -&gt; work() -&gt; prepare() 而不是 prepare() -&gt; work() -&gt; prepare() -&gt; schedule() -&gt; work() -&gt; prepare() -&gt; schedule() -&gt; .. -&gt; work() -&gt; prepare()</li>
<li>executor epoll 使用 level-triggered notifications.</li>
</ol>
</li>
<li><code> Processors expandPipeline()</code><ol>
<li><code>prepare</code> 返回 ExpandPipeline，则需要调用此方法, 方法无法访问任何端口，但可以为当前处理器创建新端口</li>
<li>方法应返回一组新的已连接处理器</li>
<li>所有添加的处理器必须仅相互连接或者连接到当前处理器</li>
<li>方法不能删除或重新连接现有端口、将数据移出/移入端口或执行计算</li>
<li> <code>prepare</code> should be called again after expanding pipeline</li>
</ol>
</li>
<li><code>void onCancel()</code></li>
</ol>
<p>具体可以看看 <code>ISimpleTransform</code> 的实现 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">ISimpleTransform::<span class="built_in">ISimpleTransform</span>(Block input_header_, Block output_header_, <span class="keyword">bool</span> skip_empty_chunks_)</span><br><span class="line">    : <span class="built_in">IProcessor</span>(&#123;std::<span class="built_in">move</span>(input_header_)&#125;, &#123;std::<span class="built_in">move</span>(output_header_)&#125;)</span><br><span class="line">    , <span class="built_in">input</span>(inputs.<span class="built_in">front</span>())</span><br><span class="line">    , <span class="built_in">output</span>(outputs.<span class="built_in">front</span>())</span><br><span class="line">    , <span class="built_in">skip_empty_chunks</span>(skip_empty_chunks_) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ISimpleTransform::Status <span class="title">ISimpleTransform::prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Check can output.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.<span class="built_in">isFinished</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        input.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> Status::Finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!output.<span class="built_in">canPush</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        input.<span class="built_in">setNotNeeded</span>();</span><br><span class="line">        <span class="keyword">return</span> Status::PortFull;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Output if has data.</span></span><br><span class="line">    <span class="keyword">if</span> (has_output)</span><br><span class="line">    &#123;</span><br><span class="line">        output.<span class="built_in">pushData</span>(std::<span class="built_in">move</span>(output_data));</span><br><span class="line">        has_output = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!no_more_data_needed)</span><br><span class="line">            <span class="keyword">return</span> Status::PortFull;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Stop if don&#x27;t need more data.</span></span><br><span class="line">    <span class="keyword">if</span> (no_more_data_needed)</span><br><span class="line">    &#123;</span><br><span class="line">        input.<span class="built_in">close</span>();</span><br><span class="line">        output.<span class="built_in">finish</span>();</span><br><span class="line">        <span class="keyword">return</span> Status::Finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Check can input.</span></span><br><span class="line">    <span class="keyword">if</span> (!has_input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">isFinished</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            output.<span class="built_in">finish</span>();</span><br><span class="line">            <span class="keyword">return</span> Status::Finished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.<span class="built_in">setNeeded</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!input.<span class="built_in">hasData</span>())</span><br><span class="line">            <span class="keyword">return</span> Status::NeedData;</span><br><span class="line"></span><br><span class="line">        input_data = input.<span class="built_in">pullData</span>(set_input_not_needed_after_read);</span><br><span class="line">        has_input = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input_data.exception)</span><br><span class="line">            <span class="comment">/// No more data needed. Exception will be thrown (or swallowed) later.</span></span><br><span class="line">            input.<span class="built_in">setNotNeeded</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Now transform.</span></span><br><span class="line">    <span class="keyword">return</span> Status::Ready;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ISimpleTransform::work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input_data.exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// Skip transform in case of exception.</span></span><br><span class="line">        output_data = std::<span class="built_in">move</span>(input_data);</span><br><span class="line">        has_input = <span class="literal">false</span>;</span><br><span class="line">        has_output = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">transform</span>(input_data.chunk, output_data.chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (DB::Exception &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        output_data.exception = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        has_output = <span class="literal">true</span>;</span><br><span class="line">        has_input = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has_input = !<span class="built_in">needInputData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skip_empty_chunks || output_data.chunk)</span><br><span class="line">        has_output = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_output &amp;&amp; !output_data.chunk &amp;&amp; <span class="built_in">getOutputPort</span>().<span class="built_in">getHeader</span>())</span><br><span class="line">        <span class="comment">/// Support invariant that chunks must have the same number of columns as header.</span></span><br><span class="line">        output_data.chunk = <span class="built_in">Chunk</span>(<span class="built_in">getOutputPort</span>().<span class="built_in">getHeader</span>().<span class="built_in">cloneEmpty</span>().<span class="built_in">getColumns</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IAccumulatingTransform</span><br><span class="line">ConcatProcessor</span><br><span class="line">DelayedPortsProcessor</span><br><span class="line">ForkProcessor</span><br><span class="line">IOutputFormat</span><br><span class="line">IInflatingTransform</span><br><span class="line">ISimpleTransform</span><br><span class="line">ISink</span><br><span class="line">ISource</span><br><span class="line">LimitTransform</span><br><span class="line">IMergingTransformBase</span><br><span class="line">OffsetTransform</span><br><span class="line">PingPongProcessor</span><br><span class="line">ResizeProcessor</span><br><span class="line">StrictResizeProcessor</span><br><span class="line">DelayedSource</span><br><span class="line">AggregatinginOrderTransform</span><br><span class="line">ConvertingAggregatedToChunksTransform</span><br><span class="line">AggregatingTransform</span><br><span class="line">CopyTransform</span><br><span class="line">ExceptionKeepingTransform</span><br><span class="line">IntersectOrExceptTransform</span><br><span class="line">JoiningTransform</span><br><span class="line">FillingRightJoinSideTransform</span><br><span class="line">GroupingAggregatedTransform</span><br><span class="line">SortingAggregatedTransform</span><br><span class="line">SortingTransform</span><br><span class="line">WindowTransform</span><br><span class="line">CopyingDataToViewsTransform</span><br><span class="line">FinalizingViewsTransform</span><br></pre></td></tr></table></figure>

<h5 id="ISimpleTransform"><a href="#ISimpleTransform" class="headerlink" title="ISimpleTransform"></a>ISimpleTransform</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MergingAggregatedBucketTransform</span><br><span class="line">TransformWithAdditionalColumns</span><br><span class="line">SendingChunkHeaderTransform</span><br><span class="line">AddingDefaultsTransform</span><br><span class="line">FinalizeAggregatedTransform</span><br><span class="line">ArrayJoinTransform</span><br><span class="line">CheckSortedTransform</span><br><span class="line">CreatingSetsOnTheFlyTransform</span><br><span class="line">FilterBySetOnTheFlyTransform</span><br><span class="line">DistinctSortedChunkTransform</span><br><span class="line">DistinctSortedTransform</span><br><span class="line">DistinctTransform</span><br><span class="line">ExpressionTransform</span><br><span class="line">ExtremesTransform</span><br><span class="line">FillingTransform</span><br><span class="line">FilterSortedStreamByRange</span><br><span class="line">FilterTransform</span><br><span class="line">LimitByTransform</span><br><span class="line">LimitsCheckingTransform</span><br><span class="line">MaterializingTransform</span><br><span class="line">PartialSortingTransform</span><br><span class="line">ReverseTransform</span><br><span class="line">TotalsHavingTransform</span><br><span class="line">WatermarkTransform</span><br><span class="line">AddingAggregatedChunkInfoTransform</span><br></pre></td></tr></table></figure>

<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><img src="/2022/10/15/clickhouse-pipeline/image-20221016182708361.png" alt="image-20221016182708361" style="zoom:50%;">

<h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>Pipe is a set of processors which represents the part of pipeline.</p>
<h5 id="port"><a href="#port" class="headerlink" title="port"></a>port</h5><p>存储数据的, clickhouse 是前后两个节点的 in 和 out 共享同一份 data 的</p>
<p>社区最新的 ClickHouse processor model, 里面有一处涉及到执行计划不同节点的数据流动, 因为在一个机器上, 实际上数据不需要真的传输, 但是需要改变数据的状态, 方便pipeline 跑起来了各个计划节点的感知. 社区的写法是, 由于内存最小按一个字节分配, 所以内存地址的末三位必定是 0, ClickHouse 搞了个指向数据的指针, 然后利用这个指针的末三位来存储状态. 在代码里你就会看到 pushData 和 pullData 的接口其实是 data 和 uintptr_t 互相在做类型转换, 顺带从位操作更新指针末三位, 这样就省下了一个字节用来保存状态.</p>
<p>InputPort 有 pullData 方法, OutputPort 有 pushData 方法，数据通过 pull 和 push 在由 port 构成的边上传递</p>
<p>在 ISource, 会构造一个空的 port</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(OutputPort &amp; output, InputPort &amp; input, <span class="keyword">bool</span> reconnect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input.output_port = &amp;output;</span><br><span class="line">    output.input_port = &amp;input;</span><br><span class="line">    input.state = std::make_shared&lt;Port::State&gt;();</span><br><span class="line">    output.state = input.state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h4><p>各个 node 分别调用自己的updatePipeline 方法, xxxStep 生成对应的 xxxTransform, 这个方法在上面介绍 step 的时候也介绍过, 例如 FilterStep-&gt;FilterTransform</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node * node = &#123;&#125;;</span><br><span class="line">    QueryPipelineBuilders pipelines = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryPipelineBuilderPtr <span class="title">QueryPlan::buildQueryPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> QueryPlanOptimizationSettings &amp; optimization_settings,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> BuildQueryPipelineSettings &amp; build_pipeline_settings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">checkInitialized</span>();</span><br><span class="line">    <span class="built_in">optimize</span>(optimization_settings);</span><br><span class="line"></span><br><span class="line">    QueryPipelineBuilderPtr last_pipeline;</span><br><span class="line"></span><br><span class="line">    std::stack&lt;Frame&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(Frame&#123;.node = root&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp; frame = stack.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last_pipeline)</span><br><span class="line">        &#123;</span><br><span class="line">            frame.pipelines.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(last_pipeline));</span><br><span class="line">            last_pipeline = <span class="literal">nullptr</span>; <span class="comment">//-V1048</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> next_child = frame.pipelines.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (next_child == frame.node-&gt;children.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> limit_max_threads = frame.pipelines.<span class="built_in">empty</span>();</span><br><span class="line">            last_pipeline = frame.node-&gt;step-&gt;<span class="built_in">updatePipeline</span>(std::<span class="built_in">move</span>(frame.pipelines), build_pipeline_settings);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (limit_max_threads &amp;&amp; max_threads)</span><br><span class="line">                last_pipeline-&gt;<span class="built_in">limitMaxThreads</span>(max_threads);</span><br><span class="line"></span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack.<span class="built_in">push</span>(Frame&#123;.node = frame.node-&gt;children[next_child]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_pipeline-&gt;<span class="built_in">setProgressCallback</span>(build_pipeline_settings.progress_callback);</span><br><span class="line">    last_pipeline-&gt;<span class="built_in">setProcessListElement</span>(build_pipeline_settings.process_list_element);</span><br><span class="line">    last_pipeline-&gt;<span class="built_in">addResources</span>(std::<span class="built_in">move</span>(resources));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last_pipeline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExecutingGraph"><a href="#ExecutingGraph" class="headerlink" title="ExecutingGraph"></a>ExecutingGraph</h3><p>pipeline在执行前，会被执行器转换成一个ExecutingGraph，由一组Node和对应的Edge集合组成，Node代表单个的Processor，Edge代表连接着OutputPort和InputPort的对象。每个Node持有两条边，分别为direct_edges和back_edges，direct_edges代表本Node的outputport连接其他inputport，back_edges代表某个outputport连接本Node的inputport</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ExecutingGraph::updateNode</span><span class="params">(<span class="keyword">uint64_t</span> pid, Queue &amp; queue, Queue &amp; async_queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stack&lt;Edge *&gt; updated_edges;</span><br><span class="line">    std::stack&lt;<span class="keyword">uint64_t</span>&gt; updated_processors;</span><br><span class="line">    updated_processors.<span class="built_in">push</span>(pid);</span><br><span class="line"></span><br><span class="line">    <span class="function">UpgradableMutex::ReadGuard <span class="title">read_lock</span><span class="params">(nodes_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!updated_processors.<span class="built_in">empty</span>() || !updated_edges.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::optional&lt;std::unique_lock&lt;std::mutex&gt;&gt; stack_top_lock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updated_processors.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> * edge = updated_edges.<span class="built_in">top</span>();</span><br><span class="line">            updated_edges.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Here we have ownership on edge, but node can be concurrently accessed.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> &amp; node = *nodes[edge-&gt;to];</span><br><span class="line"></span><br><span class="line">            <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(node.status_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            ExecutingGraph::ExecStatus status = node.status;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != ExecutingGraph::ExecStatus::Finished)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge-&gt;backward)</span><br><span class="line">                    node.updated_output_ports.<span class="built_in">push_back</span>(edge-&gt;output_port_number);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node.updated_input_ports.<span class="built_in">push_back</span>(edge-&gt;input_port_number);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (status == ExecutingGraph::ExecStatus::Idle)</span><br><span class="line">                &#123;</span><br><span class="line">                    node.status = ExecutingGraph::ExecStatus::Preparing;</span><br><span class="line">                    updated_processors.<span class="built_in">push</span>(edge-&gt;to);</span><br><span class="line">                    stack_top_lock = std::<span class="built_in">move</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nodes[edge-&gt;to]-&gt;processor-&gt;<span class="built_in">onUpdatePorts</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!updated_processors.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pid = updated_processors.<span class="built_in">top</span>();</span><br><span class="line">            updated_processors.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// In this method we have ownership on node.</span></span><br><span class="line">            <span class="keyword">auto</span> &amp; node = *nodes[pid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> need_expand_pipeline = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stack_top_lock)</span><br><span class="line">                stack_top_lock.<span class="built_in">emplace</span>(node.status_mutex);</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">                Stopwatch watch;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(std::move(*stack_top_lock))</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> &amp; processor = *node.processor;</span><br><span class="line">                    IProcessor::Status last_status = node.last_processor_status;</span><br><span class="line">                    IProcessor::Status status = processor.<span class="built_in">prepare</span>(node.updated_input_ports, node.updated_output_ports);</span><br><span class="line">                    node.last_processor_status = status;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (profile_processors)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/// NeedData</span></span><br><span class="line">                        <span class="keyword">if</span> (last_status != IProcessor::Status::NeedData &amp;&amp; status == IProcessor::Status::NeedData)</span><br><span class="line">                        &#123;</span><br><span class="line">                            processor.input_wait_watch.<span class="built_in">restart</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (last_status == IProcessor::Status::NeedData &amp;&amp; status != IProcessor::Status::NeedData)</span><br><span class="line">                        &#123;</span><br><span class="line">                            processor.input_wait_elapsed_us += processor.input_wait_watch.<span class="built_in">elapsedMicroseconds</span>();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/// PortFull</span></span><br><span class="line">                        <span class="keyword">if</span> (last_status != IProcessor::Status::PortFull &amp;&amp; status == IProcessor::Status::PortFull)</span><br><span class="line">                        &#123;</span><br><span class="line">                            processor.output_wait_watch.<span class="built_in">restart</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (last_status == IProcessor::Status::PortFull &amp;&amp; status != IProcessor::Status::PortFull)</span><br><span class="line">                        &#123;</span><br><span class="line">                            processor.output_wait_elapsed_us += processor.output_wait_watch.<span class="built_in">elapsedMicroseconds</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">                &#123;</span><br><span class="line">                    node.exception = std::<span class="built_in">current_exception</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">                node.preparation_time_ns += watch.<span class="built_in">elapsed</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                node.updated_input_ports.<span class="built_in">clear</span>();</span><br><span class="line">                node.updated_output_ports.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span> (node.last_processor_status)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::NeedData:</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::PortFull:</span><br><span class="line">                    &#123;</span><br><span class="line">                        node.status = ExecutingGraph::ExecStatus::Idle;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::Finished:</span><br><span class="line">                    &#123;</span><br><span class="line">                        node.status = ExecutingGraph::ExecStatus::Finished;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::Ready:</span><br><span class="line">                    &#123;</span><br><span class="line">                        node.status = ExecutingGraph::ExecStatus::Executing;</span><br><span class="line">                        queue.<span class="built_in">push</span>(&amp;node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::Async:</span><br><span class="line">                    &#123;</span><br><span class="line">                        node.status = ExecutingGraph::ExecStatus::Executing;</span><br><span class="line">                        async_queue.<span class="built_in">push</span>(&amp;node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> IProcessor::Status::ExpandPipeline:</span><br><span class="line">                    &#123;</span><br><span class="line">                        need_expand_pipeline = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!need_expand_pipeline)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/// If you wonder why edges are pushed in reverse order,</span></span><br><span class="line">                    <span class="comment">/// it is because updated_edges is a stack, and we prefer to get from stack</span></span><br><span class="line">                    <span class="comment">/// input ports firstly, and then outputs, both in-order.</span></span><br><span class="line">                    <span class="comment">///</span></span><br><span class="line">                    <span class="comment">/// Actually, there should be no difference in which order we process edges.</span></span><br><span class="line">                    <span class="comment">/// However, some tests are sensitive to it (e.g. something like SELECT 1 UNION ALL 2).</span></span><br><span class="line">                    <span class="comment">/// Let&#x27;s not break this behaviour so far.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.post_updated_output_ports.<span class="built_in">rbegin</span>(); it != node.post_updated_output_ports.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> * edge = <span class="keyword">static_cast</span>&lt;ExecutingGraph::Edge *&gt;(*it);</span><br><span class="line">                        updated_edges.<span class="built_in">push</span>(edge);</span><br><span class="line">                        edge-&gt;update_info.<span class="built_in">trigger</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> it = node.post_updated_input_ports.<span class="built_in">rbegin</span>(); it != node.post_updated_input_ports.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> * edge = <span class="keyword">static_cast</span>&lt;ExecutingGraph::Edge *&gt;(*it);</span><br><span class="line">                        updated_edges.<span class="built_in">push</span>(edge);</span><br><span class="line">                        edge-&gt;update_info.<span class="built_in">trigger</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    node.post_updated_input_ports.<span class="built_in">clear</span>();</span><br><span class="line">                    node.post_updated_output_ports.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need_expand_pipeline)</span><br><span class="line">            &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">UpgradableMutex::WriteGuard <span class="title">lock</span><span class="params">(read_lock)</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">expandPipeline</span>(updated_processors, pid))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// Add itself back to be prepared again.</span></span><br><span class="line">                updated_processors.<span class="built_in">push</span>(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看这里, 当 IProcessor::Status::Ready 的时候, 会把节点加到 queue 中</p>
<h3 id="PipelineExecutor"><a href="#PipelineExecutor" class="headerlink" title="PipelineExecutor"></a>PipelineExecutor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PipelineExecutor::execute(size_t num_threads)</span><br><span class="line">-&gt; executeImpl(num_threads);</span><br><span class="line">  -&gt; initializeExecution(num_threads);</span><br><span class="line">    -&gt; graph-&gt;initializeExecution(queue);</span><br><span class="line">    // 将所有direct_edges为空的Node提取出来，依次调用updateNode。</span><br><span class="line">      -&gt; updateNode(proc, queue, async_queue);               （2）</span><br><span class="line">     // 以proc为起点，调用prepare函数，如果遇到Ready的node则push到queue中，  如果遇到Async的node则push到async_queue中。然后更新与当前node关联的edge，  通过edge找到下一个node并执行该node的prepare方法，最终将所有状态为Ready      和Async的node放到对应的队列中。</span><br><span class="line">    -&gt; tasks.init();</span><br><span class="line">    -&gt; tasks.fill(queue);</span><br><span class="line">    //tasks持有线程队列和任务队列（任务队列是个二维数组，及为每个线程维护一个任务队列，详情见TaskQueue类），tasks.fill(queue)实际上就是将就绪的node依次分配到任务队列中。</span><br><span class="line">   -&gt; threads.emplace_back(executeSingleThread);</span><br><span class="line">   //在栈上创建一个线程池，依次调用executeSingleThread函数：</span><br><span class="line">     -&gt; executeStepImpl(thread_num);</span><br><span class="line">       -&gt; auto&amp; context = tasks.getThreadContext(thread_num);</span><br><span class="line">       -&gt; tasks.tryGetTask(context);</span><br><span class="line">       // 尝试从task_queue中获取一个task，如果task_queue为空并且async_task也为空的话，则将context.thread_number插入thread_queue（这个对象中记录着当前等待着task的线程id）中，并wait在wakeup_flag || finished上；如果context取到了task，则调用tryWakeupAnyOtherThreadWithTasks函数。</span><br><span class="line">         -&gt; tryWakeupAnyOtherThreadWithTasks(self, lock);</span><br><span class="line">         // 这个函数的目的在于获取一个等待任务的线程进行唤醒：executor_contexts[thread_to_wake]-&gt;wakeUp();</span><br><span class="line">       -&gt; context.executeTask();</span><br><span class="line">         -&gt; executeJob(node, read_progress_callback);</span><br><span class="line">           -&gt; node-&gt;processor-&gt;work();</span><br><span class="line">         -&gt; graph-&gt;updateNode(context.getProcessorID(), queue, async_queue);  （1）</span><br><span class="line">         -&gt; tasks.pushTasks(queue, async_queue, context);</span><br><span class="line">         // 将queue中的node插入task_queue，并唤醒其他线程来处理task</span><br><span class="line">           -&gt; tryWakeupAnyOtherThreadWithTasks(context, lock);</span><br><span class="line"></span><br><span class="line">从ExecutingGraph中获取direct_edges为空的Node并调用其prepare函数。direct_edges为空的Node一般来说就是ISink类型的节点，即最终的消费者。可以在ISink函数中看到其prepare函数的实现，首次调用时总是会返回Ready，因此调度器会调用其work函数，对ISink对象首次调用work函数会触发OnStart回调。</span><br><span class="line"></span><br><span class="line">work函数调用之后，调度器会对该节点调用updateNode函数（见（1）），updateNode具体逻辑在（2）这里，即再次调用其prepare函数。这时ISink会调用input.setNeed函数，这个函数会唤醒对应的Edge（updated_edges.push(edge)），在updateNode逻辑中会处理这些Edge，获取对应的Node继续prepare操作。</span><br><span class="line"></span><br><span class="line">因此，可以根据Edge关系从ISink节点出发，一直找到ISource节点并调用其prepare函数，对于ISource节点来说只要output_port可以push就返回Ready，由调度器调用work函数，work函数中执行tryGenerate函数（真正生成数据的函数）。因此当调度器再次执行其prepare函数时，执行output.pushData函数，这个函数和input.setNeed同样会唤醒对应的Edge，因此调度器会找到其下游节点调用prepare函数，这时数据已经从ISource节点交付，因此下游节点会返回Ready，调度器调用其work函数...从上游节点到最终的ISink节点重复这个操作。</span><br><span class="line"></span><br><span class="line">最后我们会回到ISink节点，调用其work函数，work函数中会调用consume函数消费数据。当再次调用ISink节点的prepare函数时，会再次调用input.setNeed函数，这样就形成了一个循环。</span><br><span class="line"></span><br><span class="line">可以看到，PipelineExecutor是一个pull模型的调度器，我们每次总ISink节点开始向上游节点请求数据，通过唤醒Edge将请求传递到ISource节点，在ISource节点中生产数据，交付下游节点处理，最终回到ISink节点消费数据，如果还有数据需要消费的话，ISink节点会再次向上游节点请求；当数据消费完成后，ISource节点会通过关闭output_port通知下游节点，最终完成所有数据的处理。</span><br></pre></td></tr></table></figure>

<p>其实模拟了协程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineExecutor::executeStep</span><span class="params">(std::<span class="keyword">atomic_bool</span> * yield_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_execution_initialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initializeExecution</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquire slot until we are done</span></span><br><span class="line">        single_thread_slot = slots-&gt;<span class="built_in">tryAcquire</span>();</span><br><span class="line">        <span class="keyword">if</span> (!single_thread_slot)</span><br><span class="line">            <span class="built_in">abort</span>(); <span class="comment">// Unable to allocate slot for the first thread, but we just allocated at least one slot</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yield_flag &amp;&amp; *yield_flag)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeStepImpl</span>(<span class="number">0</span>, yield_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tasks.<span class="built_in">isFinished</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Execution can be stopped because of exception. Check and rethrow if any.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; node : graph-&gt;nodes)</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;exception)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(node-&gt;exception);</span><br><span class="line"></span><br><span class="line">    single_thread_slot.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">finalizeExecution</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PipelineExecutor::executeStepImpl</span><span class="params">(<span class="keyword">size_t</span> thread_num, std::<span class="keyword">atomic_bool</span> * yield_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp; context = tasks.<span class="built_in">getThreadContext</span>(thread_num);</span><br><span class="line">    <span class="keyword">bool</span> yield = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">isFinished</span>() &amp;&amp; !yield)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// First, find any processor to execute.</span></span><br><span class="line">        <span class="comment">/// Just traverse graph and prepare any processor.</span></span><br><span class="line">        <span class="keyword">while</span> (!tasks.<span class="built_in">isFinished</span>() &amp;&amp; !context.<span class="built_in">hasTask</span>())</span><br><span class="line">            tasks.<span class="built_in">tryGetTask</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (context.<span class="built_in">hasTask</span>() &amp;&amp; !yield)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tasks.<span class="built_in">isFinished</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!context.<span class="built_in">executeTask</span>())</span><br><span class="line">                <span class="built_in">cancel</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tasks.<span class="built_in">isFinished</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checkTimeLimitSoft</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Try to execute neighbour processor.</span></span><br><span class="line">            &#123;</span><br><span class="line">                Queue queue;</span><br><span class="line">                Queue async_queue;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// Prepare processor after execution.</span></span><br><span class="line">                <span class="keyword">if</span> (!graph-&gt;<span class="built_in">updateNode</span>(context.<span class="built_in">getProcessorID</span>(), queue, async_queue))</span><br><span class="line">                    <span class="built_in">finish</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// Push other tasks to global queue.</span></span><br><span class="line">                tasks.<span class="built_in">pushTasks</span>(queue, async_queue, context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Upscale if possible.</span></span><br><span class="line">            <span class="built_in">spawnThreads</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// We have executed single processor. Check if we need to yield execution.</span></span><br><span class="line">            <span class="keyword">if</span> (yield_flag &amp;&amp; *yield_flag)</span><br><span class="line">                yield = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/314808">https://bbs.huaweicloud.com/blogs/314808</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014445499/article/details/115309076">https://blog.csdn.net/u014445499/article/details/115309076</a></p>
<p><a target="_blank" rel="noopener" href="https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/">https://bohutang.me/2020/06/11/clickhouse-and-friends-processor/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/545776764">https://zhuanlan.zhihu.com/p/545776764</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/clickhouse/" rel="tag"><i class="fa fa-tag"></i> clickhouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/06/cpp-thread/" rel="prev" title="CPP 并发编程实战">
      <i class="fa fa-chevron-left"></i> CPP 并发编程实战
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">基本流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">具体流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Interpreter"><span class="nav-number">2.1.</span> <span class="nav-text">Interpreter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#buildQueryPlan"><span class="nav-number">2.1.1.</span> <span class="nav-text">buildQueryPlan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buildQueryPipeline"><span class="nav-number">2.1.2.</span> <span class="nav-text">buildQueryPipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutingGraph"><span class="nav-number">2.1.3.</span> <span class="nav-text">ExecutingGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PipelineExecutor"><span class="nav-number">2.1.4.</span> <span class="nav-text">PipelineExecutor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiatao Tao"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">Jiatao Tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aaaaaaron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aaaaaaron" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tao@apache.org" title="E-Mail → mailto:tao@apache.org" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiatao Tao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a>
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
